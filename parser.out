Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> prog0 program_a lol program_c program_d main
Rule 2     lol -> <empty>
Rule 3     program_a -> program_b program_a
Rule 4     program_a -> empty
Rule 5     program_b -> let prog1
Rule 6     program_b -> class prog2
Rule 7     program_c -> var prog3 program_c
Rule 8     program_c -> empty
Rule 9     program_d -> function prog4 program_d
Rule 10    program_d -> empty
Rule 11    prog0 -> <empty>
Rule 12    prog1 -> <empty>
Rule 13    prog2 -> <empty>
Rule 14    prog3 -> <empty>
Rule 15    prog4 -> <empty>
Rule 16    type -> type0 atomic
Rule 17    typeM -> type0 LC CTE_I RC LC CTE_I RC atomic type1
Rule 18    typeM -> type0 LC CTE_I RC atomic type2
Rule 19    typeM -> type0 ID type4
Rule 20    type0 -> <empty>
Rule 21    type1 -> <empty>
Rule 22    type2 -> <empty>
Rule 23    type3 -> <empty>
Rule 24    type4 -> <empty>
Rule 25    atomic -> INT type3
Rule 26    atomic -> FLOAT type3
Rule 27    atomic -> BOOL type3
Rule 28    var -> VAR ID var1 COL type var2 var_a SEMICOL
Rule 29    var -> VAR ID var1 COL typeM SEMICOL var2
Rule 30    var_a -> IS var_b var3
Rule 31    var_a -> empty
Rule 32    var_b -> CTE_I var4
Rule 33    var_b -> CTE_F var5
Rule 34    var_b -> CTE_B var6
Rule 35    var1 -> <empty>
Rule 36    var2 -> <empty>
Rule 37    var3 -> <empty>
Rule 38    var4 -> <empty>
Rule 39    var5 -> <empty>
Rule 40    var6 -> <empty>
Rule 41    let -> LET ID let1 COL type let2 IS var_b SEMICOL let3
Rule 42    let1 -> <empty>
Rule 43    let2 -> <empty>
Rule 44    let3 -> <empty>
Rule 45    main -> MAIN LP RP function_block
Rule 46    function -> FUNCTION ID LP params RP function_a function_block
Rule 47    function_a -> ARROW type
Rule 48    function_a -> empty
Rule 49    params -> ID COL type params_a
Rule 50    params -> empty
Rule 51    params_a -> COMMA params
Rule 52    params_a -> empty
Rule 53    block -> LB block_a RB
Rule 54    block_a -> statement block_a
Rule 55    block_a -> empty
Rule 56    function_block -> LB function_block_a block_a RB
Rule 57    function_block_a -> function_block_b function_block_a
Rule 58    function_block_a -> empty
Rule 59    function_block_b -> var
Rule 60    function_block_b -> let
Rule 61    class -> CLASS ID class1 class_a LB class_b init class_c class_d RB
Rule 62    class_a -> COL ID
Rule 63    class_a -> empty
Rule 64    class_b -> class_e class_f class_b
Rule 65    class_b -> empty
Rule 66    class_e -> PRIVATE
Rule 67    class_e -> empty
Rule 68    class_f -> var
Rule 69    class_f -> let
Rule 70    class_c -> init class_c
Rule 71    class_c -> empty
Rule 72    class_d -> class_e function class_d
Rule 73    class_d -> empty
Rule 74    class1 -> <empty>
Rule 75    init -> INIT LP params RP block
Rule 76    statement -> print
Rule 77    statement -> input
Rule 78    statement -> assignment
Rule 79    statement -> condition
Rule 80    statement -> loop
Rule 81    statement -> call_function
Rule 82    statement -> return
Rule 83    return -> RETURN expression SEMICOL
Rule 84    obj -> ID array attribute
Rule 85    assignment -> obj IS expression SEMICOL
Rule 86    print -> PRINT LP print_a RP SEMICOL
Rule 87    print_a -> expression
Rule 88    print_a -> CTE_S
Rule 89    print_a -> empty
Rule 90    input -> INPUT LP obj RP SEMICOL
Rule 91    loop -> WHILE expression block
Rule 92    call_function -> obj call_func SEMICOL
Rule 93    call_params -> expression call_params_a
Rule 94    call_params -> empty
Rule 95    call_params_a -> COMMA expression call_params_a
Rule 96    call_params_a -> empty
Rule 97    condition -> IF expression block condition_a condition_b
Rule 98    condition_a -> elseif condition_a
Rule 99    condition_a -> empty
Rule 100   condition_b -> else
Rule 101   condition_b -> empty
Rule 102   elseif -> ELSEIF expression block
Rule 103   else -> ELSE block
Rule 104   expression -> comparison expression_a
Rule 105   expression_a -> AND comparison expression_a
Rule 106   expression_a -> OR comparison
Rule 107   expression_a -> empty
Rule 108   comparison -> exp comparison_a
Rule 109   comparison_a -> comparison_b exp comparison_a
Rule 110   comparison_a -> empty
Rule 111   comparison_b -> GEQ
Rule 112   comparison_b -> LEQ
Rule 113   comparison_b -> GT
Rule 114   comparison_b -> LT
Rule 115   comparison_b -> EQUAL
Rule 116   comparison_b -> NEQ
Rule 117   exp -> term exp_a
Rule 118   exp_a -> PLUS term exp_a
Rule 119   exp_a -> MINUS term exp_a
Rule 120   exp_a -> empty
Rule 121   term -> factor term_a
Rule 122   term_a -> MUL factor term_a
Rule 123   term_a -> DIV factor term_a
Rule 124   term_a -> empty
Rule 125   factor -> LP expression RP
Rule 126   factor -> factor_a var_cte
Rule 127   factor_a -> MINUS
Rule 128   factor_a -> NOT
Rule 129   factor_a -> empty
Rule 130   var_cte -> obj call_func_optional
Rule 131   var_cte -> CTE_I
Rule 132   var_cte -> CTE_F
Rule 133   var_cte -> CTE_B
Rule 134   array -> LC expression RC array_a
Rule 135   array -> empty
Rule 136   array_a -> LC expression RC
Rule 137   array_a -> empty
Rule 138   attribute -> DOT ID
Rule 139   attribute -> empty
Rule 140   call_func -> LP call_params RP
Rule 141   call_func_optional -> call_func
Rule 142   call_func_optional -> empty
Rule 143   empty -> <empty>

Terminals, with rules where they appear

AND                  : 105
ARROW                : 47
BOOL                 : 27
CLASS                : 61
COL                  : 28 29 41 49 62
COMMA                : 51 95
CTE_B                : 34 133
CTE_F                : 33 132
CTE_I                : 17 17 18 32 131
CTE_S                : 88
DIV                  : 123
DOT                  : 138
ELSE                 : 103
ELSEIF               : 102
EQUAL                : 115
FLOAT                : 26
FUNCTION             : 46
GEQ                  : 111
GT                   : 113
ID                   : 19 28 29 41 46 49 61 62 84 138
IF                   : 97
INIT                 : 75
INPUT                : 90
INT                  : 25
IS                   : 30 41 85
LB                   : 53 56 61
LC                   : 17 17 18 134 136
LEQ                  : 112
LET                  : 41
LP                   : 45 46 75 86 90 125 140
LT                   : 114
MAIN                 : 45
MINUS                : 119 127
MUL                  : 122
NEQ                  : 116
NOT                  : 128
OR                   : 106
PLUS                 : 118
PRINT                : 86
PRIVATE              : 66
RB                   : 53 56 61
RC                   : 17 17 18 134 136
RETURN               : 83
RP                   : 45 46 75 86 90 125 140
SEMICOL              : 28 29 41 83 85 86 90 92
VAR                  : 28 29
WHILE                : 91
error                : 

Nonterminals, with rules where they appear

array                : 84
array_a              : 134
assignment           : 78
atomic               : 16 17 18
attribute            : 84
block                : 75 91 97 102 103
block_a              : 53 54 56
call_func            : 92 141
call_func_optional   : 130
call_function        : 81
call_params          : 140
call_params_a        : 93 95
class                : 6
class1               : 61
class_a              : 61
class_b              : 61 64
class_c              : 61 70
class_d              : 61 72
class_e              : 64 72
class_f              : 64
comparison           : 104 105 106
comparison_a         : 108 109
comparison_b         : 109
condition            : 79
condition_a          : 97 98
condition_b          : 97
else                 : 100
elseif               : 98
empty                : 4 8 10 31 48 50 52 55 58 63 65 67 71 73 89 94 96 99 101 107 110 120 124 129 135 137 139 142
exp                  : 108 109
exp_a                : 117 118 119
expression           : 83 85 87 91 93 95 97 102 125 134 136
expression_a         : 104 105
factor               : 121 122 123
factor_a             : 126
function             : 9 72
function_a           : 46
function_block       : 45 46
function_block_a     : 56 57
function_block_b     : 57
init                 : 61 70
input                : 77
let                  : 5 60 69
let1                 : 41
let2                 : 41
let3                 : 41
lol                  : 1
loop                 : 80
main                 : 1
obj                  : 85 90 92 130
params               : 46 51 75
params_a             : 49
print                : 76
print_a              : 86
prog0                : 1
prog1                : 5
prog2                : 6
prog3                : 7
prog4                : 9
program              : 0
program_a            : 1 3
program_b            : 3
program_c            : 1 7
program_d            : 1 9
return               : 82
statement            : 54
term                 : 117 118 119
term_a               : 121 122 123
type                 : 28 41 47 49
type0                : 16 17 18 19
type1                : 17
type2                : 18
type3                : 25 26 27
type4                : 19
typeM                : 29
var                  : 7 59 68
var1                 : 28 29
var2                 : 28 29
var3                 : 30
var4                 : 32
var5                 : 33
var6                 : 34
var_a                : 28
var_b                : 30 41
var_cte              : 126

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . prog0 program_a lol program_c program_d main
    (11) prog0 -> .

    LET             reduce using rule 11 (prog0 -> .)
    CLASS           reduce using rule 11 (prog0 -> .)
    VAR             reduce using rule 11 (prog0 -> .)
    FUNCTION        reduce using rule 11 (prog0 -> .)
    MAIN            reduce using rule 11 (prog0 -> .)

    program                        shift and go to state 1
    prog0                          shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> prog0 . program_a lol program_c program_d main
    (3) program_a -> . program_b program_a
    (4) program_a -> . empty
    (5) program_b -> . let prog1
    (6) program_b -> . class prog2
    (143) empty -> .
    (41) let -> . LET ID let1 COL type let2 IS var_b SEMICOL let3
    (61) class -> . CLASS ID class1 class_a LB class_b init class_c class_d RB

    VAR             reduce using rule 143 (empty -> .)
    FUNCTION        reduce using rule 143 (empty -> .)
    MAIN            reduce using rule 143 (empty -> .)
    LET             shift and go to state 8
    CLASS           shift and go to state 9

    program_a                      shift and go to state 3
    program_b                      shift and go to state 4
    empty                          shift and go to state 5
    let                            shift and go to state 6
    class                          shift and go to state 7

state 3

    (1) program -> prog0 program_a . lol program_c program_d main
    (2) lol -> .

    VAR             reduce using rule 2 (lol -> .)
    FUNCTION        reduce using rule 2 (lol -> .)
    MAIN            reduce using rule 2 (lol -> .)

    lol                            shift and go to state 10

state 4

    (3) program_a -> program_b . program_a
    (3) program_a -> . program_b program_a
    (4) program_a -> . empty
    (5) program_b -> . let prog1
    (6) program_b -> . class prog2
    (143) empty -> .
    (41) let -> . LET ID let1 COL type let2 IS var_b SEMICOL let3
    (61) class -> . CLASS ID class1 class_a LB class_b init class_c class_d RB

    VAR             reduce using rule 143 (empty -> .)
    FUNCTION        reduce using rule 143 (empty -> .)
    MAIN            reduce using rule 143 (empty -> .)
    LET             shift and go to state 8
    CLASS           shift and go to state 9

    program_b                      shift and go to state 4
    program_a                      shift and go to state 11
    empty                          shift and go to state 5
    let                            shift and go to state 6
    class                          shift and go to state 7

state 5

    (4) program_a -> empty .

    VAR             reduce using rule 4 (program_a -> empty .)
    FUNCTION        reduce using rule 4 (program_a -> empty .)
    MAIN            reduce using rule 4 (program_a -> empty .)


state 6

    (5) program_b -> let . prog1
    (12) prog1 -> .

    LET             reduce using rule 12 (prog1 -> .)
    CLASS           reduce using rule 12 (prog1 -> .)
    VAR             reduce using rule 12 (prog1 -> .)
    FUNCTION        reduce using rule 12 (prog1 -> .)
    MAIN            reduce using rule 12 (prog1 -> .)

    prog1                          shift and go to state 12

state 7

    (6) program_b -> class . prog2
    (13) prog2 -> .

    LET             reduce using rule 13 (prog2 -> .)
    CLASS           reduce using rule 13 (prog2 -> .)
    VAR             reduce using rule 13 (prog2 -> .)
    FUNCTION        reduce using rule 13 (prog2 -> .)
    MAIN            reduce using rule 13 (prog2 -> .)

    prog2                          shift and go to state 13

state 8

    (41) let -> LET . ID let1 COL type let2 IS var_b SEMICOL let3

    ID              shift and go to state 14


state 9

    (61) class -> CLASS . ID class1 class_a LB class_b init class_c class_d RB

    ID              shift and go to state 15


state 10

    (1) program -> prog0 program_a lol . program_c program_d main
    (7) program_c -> . var prog3 program_c
    (8) program_c -> . empty
    (28) var -> . VAR ID var1 COL type var2 var_a SEMICOL
    (29) var -> . VAR ID var1 COL typeM SEMICOL var2
    (143) empty -> .

    VAR             shift and go to state 19
    FUNCTION        reduce using rule 143 (empty -> .)
    MAIN            reduce using rule 143 (empty -> .)

    program_c                      shift and go to state 16
    var                            shift and go to state 17
    empty                          shift and go to state 18

state 11

    (3) program_a -> program_b program_a .

    VAR             reduce using rule 3 (program_a -> program_b program_a .)
    FUNCTION        reduce using rule 3 (program_a -> program_b program_a .)
    MAIN            reduce using rule 3 (program_a -> program_b program_a .)


state 12

    (5) program_b -> let prog1 .

    LET             reduce using rule 5 (program_b -> let prog1 .)
    CLASS           reduce using rule 5 (program_b -> let prog1 .)
    VAR             reduce using rule 5 (program_b -> let prog1 .)
    FUNCTION        reduce using rule 5 (program_b -> let prog1 .)
    MAIN            reduce using rule 5 (program_b -> let prog1 .)


state 13

    (6) program_b -> class prog2 .

    LET             reduce using rule 6 (program_b -> class prog2 .)
    CLASS           reduce using rule 6 (program_b -> class prog2 .)
    VAR             reduce using rule 6 (program_b -> class prog2 .)
    FUNCTION        reduce using rule 6 (program_b -> class prog2 .)
    MAIN            reduce using rule 6 (program_b -> class prog2 .)


state 14

    (41) let -> LET ID . let1 COL type let2 IS var_b SEMICOL let3
    (42) let1 -> .

    COL             reduce using rule 42 (let1 -> .)

    let1                           shift and go to state 20

state 15

    (61) class -> CLASS ID . class1 class_a LB class_b init class_c class_d RB
    (74) class1 -> .

    COL             reduce using rule 74 (class1 -> .)
    LB              reduce using rule 74 (class1 -> .)

    class1                         shift and go to state 21

state 16

    (1) program -> prog0 program_a lol program_c . program_d main
    (9) program_d -> . function prog4 program_d
    (10) program_d -> . empty
    (46) function -> . FUNCTION ID LP params RP function_a function_block
    (143) empty -> .

    FUNCTION        shift and go to state 25
    MAIN            reduce using rule 143 (empty -> .)

    program_d                      shift and go to state 22
    function                       shift and go to state 23
    empty                          shift and go to state 24

state 17

    (7) program_c -> var . prog3 program_c
    (14) prog3 -> .

    VAR             reduce using rule 14 (prog3 -> .)
    FUNCTION        reduce using rule 14 (prog3 -> .)
    MAIN            reduce using rule 14 (prog3 -> .)

    prog3                          shift and go to state 26

state 18

    (8) program_c -> empty .

    FUNCTION        reduce using rule 8 (program_c -> empty .)
    MAIN            reduce using rule 8 (program_c -> empty .)


state 19

    (28) var -> VAR . ID var1 COL type var2 var_a SEMICOL
    (29) var -> VAR . ID var1 COL typeM SEMICOL var2

    ID              shift and go to state 27


state 20

    (41) let -> LET ID let1 . COL type let2 IS var_b SEMICOL let3

    COL             shift and go to state 28


state 21

    (61) class -> CLASS ID class1 . class_a LB class_b init class_c class_d RB
    (62) class_a -> . COL ID
    (63) class_a -> . empty
    (143) empty -> .

    COL             shift and go to state 30
    LB              reduce using rule 143 (empty -> .)

    class_a                        shift and go to state 29
    empty                          shift and go to state 31

state 22

    (1) program -> prog0 program_a lol program_c program_d . main
    (45) main -> . MAIN LP RP function_block

    MAIN            shift and go to state 33

    main                           shift and go to state 32

state 23

    (9) program_d -> function . prog4 program_d
    (15) prog4 -> .

    FUNCTION        reduce using rule 15 (prog4 -> .)
    MAIN            reduce using rule 15 (prog4 -> .)

    prog4                          shift and go to state 34

state 24

    (10) program_d -> empty .

    MAIN            reduce using rule 10 (program_d -> empty .)


state 25

    (46) function -> FUNCTION . ID LP params RP function_a function_block

    ID              shift and go to state 35


state 26

    (7) program_c -> var prog3 . program_c
    (7) program_c -> . var prog3 program_c
    (8) program_c -> . empty
    (28) var -> . VAR ID var1 COL type var2 var_a SEMICOL
    (29) var -> . VAR ID var1 COL typeM SEMICOL var2
    (143) empty -> .

    VAR             shift and go to state 19
    FUNCTION        reduce using rule 143 (empty -> .)
    MAIN            reduce using rule 143 (empty -> .)

    var                            shift and go to state 17
    program_c                      shift and go to state 36
    empty                          shift and go to state 18

state 27

    (28) var -> VAR ID . var1 COL type var2 var_a SEMICOL
    (29) var -> VAR ID . var1 COL typeM SEMICOL var2
    (35) var1 -> .

    COL             reduce using rule 35 (var1 -> .)

    var1                           shift and go to state 37

state 28

    (41) let -> LET ID let1 COL . type let2 IS var_b SEMICOL let3
    (16) type -> . type0 atomic
    (20) type0 -> .

    INT             reduce using rule 20 (type0 -> .)
    FLOAT           reduce using rule 20 (type0 -> .)
    BOOL            reduce using rule 20 (type0 -> .)

    type                           shift and go to state 38
    type0                          shift and go to state 39

state 29

    (61) class -> CLASS ID class1 class_a . LB class_b init class_c class_d RB

    LB              shift and go to state 40


state 30

    (62) class_a -> COL . ID

    ID              shift and go to state 41


state 31

    (63) class_a -> empty .

    LB              reduce using rule 63 (class_a -> empty .)


state 32

    (1) program -> prog0 program_a lol program_c program_d main .

    $end            reduce using rule 1 (program -> prog0 program_a lol program_c program_d main .)


state 33

    (45) main -> MAIN . LP RP function_block

    LP              shift and go to state 42


state 34

    (9) program_d -> function prog4 . program_d
    (9) program_d -> . function prog4 program_d
    (10) program_d -> . empty
    (46) function -> . FUNCTION ID LP params RP function_a function_block
    (143) empty -> .

    FUNCTION        shift and go to state 25
    MAIN            reduce using rule 143 (empty -> .)

    function                       shift and go to state 23
    program_d                      shift and go to state 43
    empty                          shift and go to state 24

state 35

    (46) function -> FUNCTION ID . LP params RP function_a function_block

    LP              shift and go to state 44


state 36

    (7) program_c -> var prog3 program_c .

    FUNCTION        reduce using rule 7 (program_c -> var prog3 program_c .)
    MAIN            reduce using rule 7 (program_c -> var prog3 program_c .)


state 37

    (28) var -> VAR ID var1 . COL type var2 var_a SEMICOL
    (29) var -> VAR ID var1 . COL typeM SEMICOL var2

    COL             shift and go to state 45


state 38

    (41) let -> LET ID let1 COL type . let2 IS var_b SEMICOL let3
    (43) let2 -> .

    IS              reduce using rule 43 (let2 -> .)

    let2                           shift and go to state 46

state 39

    (16) type -> type0 . atomic
    (25) atomic -> . INT type3
    (26) atomic -> . FLOAT type3
    (27) atomic -> . BOOL type3

    INT             shift and go to state 48
    FLOAT           shift and go to state 49
    BOOL            shift and go to state 50

    atomic                         shift and go to state 47

state 40

    (61) class -> CLASS ID class1 class_a LB . class_b init class_c class_d RB
    (64) class_b -> . class_e class_f class_b
    (65) class_b -> . empty
    (66) class_e -> . PRIVATE
    (67) class_e -> . empty
    (143) empty -> .

    PRIVATE         shift and go to state 54
    INIT            reduce using rule 143 (empty -> .)
    VAR             reduce using rule 143 (empty -> .)
    LET             reduce using rule 143 (empty -> .)

    class_b                        shift and go to state 51
    class_e                        shift and go to state 52
    empty                          shift and go to state 53

state 41

    (62) class_a -> COL ID .

    LB              reduce using rule 62 (class_a -> COL ID .)


state 42

    (45) main -> MAIN LP . RP function_block

    RP              shift and go to state 55


state 43

    (9) program_d -> function prog4 program_d .

    MAIN            reduce using rule 9 (program_d -> function prog4 program_d .)


state 44

    (46) function -> FUNCTION ID LP . params RP function_a function_block
    (49) params -> . ID COL type params_a
    (50) params -> . empty
    (143) empty -> .

    ID              shift and go to state 56
    RP              reduce using rule 143 (empty -> .)

    params                         shift and go to state 57
    empty                          shift and go to state 58

state 45

    (28) var -> VAR ID var1 COL . type var2 var_a SEMICOL
    (29) var -> VAR ID var1 COL . typeM SEMICOL var2
    (16) type -> . type0 atomic
    (17) typeM -> . type0 LC CTE_I RC LC CTE_I RC atomic type1
    (18) typeM -> . type0 LC CTE_I RC atomic type2
    (19) typeM -> . type0 ID type4
    (20) type0 -> .

    LC              reduce using rule 20 (type0 -> .)
    ID              reduce using rule 20 (type0 -> .)
    INT             reduce using rule 20 (type0 -> .)
    FLOAT           reduce using rule 20 (type0 -> .)
    BOOL            reduce using rule 20 (type0 -> .)

    type                           shift and go to state 59
    typeM                          shift and go to state 60
    type0                          shift and go to state 61

state 46

    (41) let -> LET ID let1 COL type let2 . IS var_b SEMICOL let3

    IS              shift and go to state 62


state 47

    (16) type -> type0 atomic .

    IS              reduce using rule 16 (type -> type0 atomic .)
    SEMICOL         reduce using rule 16 (type -> type0 atomic .)
    COMMA           reduce using rule 16 (type -> type0 atomic .)
    RP              reduce using rule 16 (type -> type0 atomic .)
    LB              reduce using rule 16 (type -> type0 atomic .)


state 48

    (25) atomic -> INT . type3
    (23) type3 -> .

    IS              reduce using rule 23 (type3 -> .)
    COMMA           reduce using rule 23 (type3 -> .)
    RP              reduce using rule 23 (type3 -> .)
    LB              reduce using rule 23 (type3 -> .)
    SEMICOL         reduce using rule 23 (type3 -> .)

    type3                          shift and go to state 63

state 49

    (26) atomic -> FLOAT . type3
    (23) type3 -> .

    IS              reduce using rule 23 (type3 -> .)
    COMMA           reduce using rule 23 (type3 -> .)
    RP              reduce using rule 23 (type3 -> .)
    LB              reduce using rule 23 (type3 -> .)
    SEMICOL         reduce using rule 23 (type3 -> .)

    type3                          shift and go to state 64

state 50

    (27) atomic -> BOOL . type3
    (23) type3 -> .

    IS              reduce using rule 23 (type3 -> .)
    COMMA           reduce using rule 23 (type3 -> .)
    RP              reduce using rule 23 (type3 -> .)
    LB              reduce using rule 23 (type3 -> .)
    SEMICOL         reduce using rule 23 (type3 -> .)

    type3                          shift and go to state 65

state 51

    (61) class -> CLASS ID class1 class_a LB class_b . init class_c class_d RB
    (75) init -> . INIT LP params RP block

    INIT            shift and go to state 67

    init                           shift and go to state 66

state 52

    (64) class_b -> class_e . class_f class_b
    (68) class_f -> . var
    (69) class_f -> . let
    (28) var -> . VAR ID var1 COL type var2 var_a SEMICOL
    (29) var -> . VAR ID var1 COL typeM SEMICOL var2
    (41) let -> . LET ID let1 COL type let2 IS var_b SEMICOL let3

    VAR             shift and go to state 19
    LET             shift and go to state 8

    class_f                        shift and go to state 68
    var                            shift and go to state 69
    let                            shift and go to state 70

state 53

    (65) class_b -> empty .
    (67) class_e -> empty .

    INIT            reduce using rule 65 (class_b -> empty .)
    VAR             reduce using rule 67 (class_e -> empty .)
    LET             reduce using rule 67 (class_e -> empty .)


state 54

    (66) class_e -> PRIVATE .

    VAR             reduce using rule 66 (class_e -> PRIVATE .)
    LET             reduce using rule 66 (class_e -> PRIVATE .)
    FUNCTION        reduce using rule 66 (class_e -> PRIVATE .)


state 55

    (45) main -> MAIN LP RP . function_block
    (56) function_block -> . LB function_block_a block_a RB

    LB              shift and go to state 72

    function_block                 shift and go to state 71

state 56

    (49) params -> ID . COL type params_a

    COL             shift and go to state 73


state 57

    (46) function -> FUNCTION ID LP params . RP function_a function_block

    RP              shift and go to state 74


state 58

    (50) params -> empty .

    RP              reduce using rule 50 (params -> empty .)


state 59

    (28) var -> VAR ID var1 COL type . var2 var_a SEMICOL
    (36) var2 -> .

    IS              reduce using rule 36 (var2 -> .)
    SEMICOL         reduce using rule 36 (var2 -> .)

    var2                           shift and go to state 75

state 60

    (29) var -> VAR ID var1 COL typeM . SEMICOL var2

    SEMICOL         shift and go to state 76


state 61

    (16) type -> type0 . atomic
    (17) typeM -> type0 . LC CTE_I RC LC CTE_I RC atomic type1
    (18) typeM -> type0 . LC CTE_I RC atomic type2
    (19) typeM -> type0 . ID type4
    (25) atomic -> . INT type3
    (26) atomic -> . FLOAT type3
    (27) atomic -> . BOOL type3

    LC              shift and go to state 77
    ID              shift and go to state 78
    INT             shift and go to state 48
    FLOAT           shift and go to state 49
    BOOL            shift and go to state 50

    atomic                         shift and go to state 47

state 62

    (41) let -> LET ID let1 COL type let2 IS . var_b SEMICOL let3
    (32) var_b -> . CTE_I var4
    (33) var_b -> . CTE_F var5
    (34) var_b -> . CTE_B var6

    CTE_I           shift and go to state 80
    CTE_F           shift and go to state 81
    CTE_B           shift and go to state 82

    var_b                          shift and go to state 79

state 63

    (25) atomic -> INT type3 .

    IS              reduce using rule 25 (atomic -> INT type3 .)
    COMMA           reduce using rule 25 (atomic -> INT type3 .)
    RP              reduce using rule 25 (atomic -> INT type3 .)
    LB              reduce using rule 25 (atomic -> INT type3 .)
    SEMICOL         reduce using rule 25 (atomic -> INT type3 .)


state 64

    (26) atomic -> FLOAT type3 .

    IS              reduce using rule 26 (atomic -> FLOAT type3 .)
    COMMA           reduce using rule 26 (atomic -> FLOAT type3 .)
    RP              reduce using rule 26 (atomic -> FLOAT type3 .)
    LB              reduce using rule 26 (atomic -> FLOAT type3 .)
    SEMICOL         reduce using rule 26 (atomic -> FLOAT type3 .)


state 65

    (27) atomic -> BOOL type3 .

    IS              reduce using rule 27 (atomic -> BOOL type3 .)
    COMMA           reduce using rule 27 (atomic -> BOOL type3 .)
    RP              reduce using rule 27 (atomic -> BOOL type3 .)
    LB              reduce using rule 27 (atomic -> BOOL type3 .)
    SEMICOL         reduce using rule 27 (atomic -> BOOL type3 .)


state 66

    (61) class -> CLASS ID class1 class_a LB class_b init . class_c class_d RB
    (70) class_c -> . init class_c
    (71) class_c -> . empty
    (75) init -> . INIT LP params RP block
    (143) empty -> .

    INIT            shift and go to state 67
    PRIVATE         reduce using rule 143 (empty -> .)
    RB              reduce using rule 143 (empty -> .)
    FUNCTION        reduce using rule 143 (empty -> .)

    init                           shift and go to state 83
    class_c                        shift and go to state 84
    empty                          shift and go to state 85

state 67

    (75) init -> INIT . LP params RP block

    LP              shift and go to state 86


state 68

    (64) class_b -> class_e class_f . class_b
    (64) class_b -> . class_e class_f class_b
    (65) class_b -> . empty
    (66) class_e -> . PRIVATE
    (67) class_e -> . empty
    (143) empty -> .

    PRIVATE         shift and go to state 54
    INIT            reduce using rule 143 (empty -> .)
    VAR             reduce using rule 143 (empty -> .)
    LET             reduce using rule 143 (empty -> .)

    class_e                        shift and go to state 52
    class_b                        shift and go to state 87
    empty                          shift and go to state 53

state 69

    (68) class_f -> var .

    PRIVATE         reduce using rule 68 (class_f -> var .)
    VAR             reduce using rule 68 (class_f -> var .)
    LET             reduce using rule 68 (class_f -> var .)
    INIT            reduce using rule 68 (class_f -> var .)


state 70

    (69) class_f -> let .

    PRIVATE         reduce using rule 69 (class_f -> let .)
    VAR             reduce using rule 69 (class_f -> let .)
    LET             reduce using rule 69 (class_f -> let .)
    INIT            reduce using rule 69 (class_f -> let .)


state 71

    (45) main -> MAIN LP RP function_block .

    $end            reduce using rule 45 (main -> MAIN LP RP function_block .)


state 72

    (56) function_block -> LB . function_block_a block_a RB
    (57) function_block_a -> . function_block_b function_block_a
    (58) function_block_a -> . empty
    (59) function_block_b -> . var
    (60) function_block_b -> . let
    (143) empty -> .
    (28) var -> . VAR ID var1 COL type var2 var_a SEMICOL
    (29) var -> . VAR ID var1 COL typeM SEMICOL var2
    (41) let -> . LET ID let1 COL type let2 IS var_b SEMICOL let3

    PRINT           reduce using rule 143 (empty -> .)
    INPUT           reduce using rule 143 (empty -> .)
    IF              reduce using rule 143 (empty -> .)
    WHILE           reduce using rule 143 (empty -> .)
    RETURN          reduce using rule 143 (empty -> .)
    ID              reduce using rule 143 (empty -> .)
    RB              reduce using rule 143 (empty -> .)
    VAR             shift and go to state 19
    LET             shift and go to state 8

    function_block_a               shift and go to state 88
    function_block_b               shift and go to state 89
    empty                          shift and go to state 90
    var                            shift and go to state 91
    let                            shift and go to state 92

state 73

    (49) params -> ID COL . type params_a
    (16) type -> . type0 atomic
    (20) type0 -> .

    INT             reduce using rule 20 (type0 -> .)
    FLOAT           reduce using rule 20 (type0 -> .)
    BOOL            reduce using rule 20 (type0 -> .)

    type                           shift and go to state 93
    type0                          shift and go to state 39

state 74

    (46) function -> FUNCTION ID LP params RP . function_a function_block
    (47) function_a -> . ARROW type
    (48) function_a -> . empty
    (143) empty -> .

    ARROW           shift and go to state 95
    LB              reduce using rule 143 (empty -> .)

    function_a                     shift and go to state 94
    empty                          shift and go to state 96

state 75

    (28) var -> VAR ID var1 COL type var2 . var_a SEMICOL
    (30) var_a -> . IS var_b var3
    (31) var_a -> . empty
    (143) empty -> .

    IS              shift and go to state 98
    SEMICOL         reduce using rule 143 (empty -> .)

    var_a                          shift and go to state 97
    empty                          shift and go to state 99

state 76

    (29) var -> VAR ID var1 COL typeM SEMICOL . var2
    (36) var2 -> .

    VAR             reduce using rule 36 (var2 -> .)
    FUNCTION        reduce using rule 36 (var2 -> .)
    MAIN            reduce using rule 36 (var2 -> .)
    PRIVATE         reduce using rule 36 (var2 -> .)
    LET             reduce using rule 36 (var2 -> .)
    INIT            reduce using rule 36 (var2 -> .)
    PRINT           reduce using rule 36 (var2 -> .)
    INPUT           reduce using rule 36 (var2 -> .)
    IF              reduce using rule 36 (var2 -> .)
    WHILE           reduce using rule 36 (var2 -> .)
    RETURN          reduce using rule 36 (var2 -> .)
    ID              reduce using rule 36 (var2 -> .)
    RB              reduce using rule 36 (var2 -> .)

    var2                           shift and go to state 100

state 77

    (17) typeM -> type0 LC . CTE_I RC LC CTE_I RC atomic type1
    (18) typeM -> type0 LC . CTE_I RC atomic type2

    CTE_I           shift and go to state 101


state 78

    (19) typeM -> type0 ID . type4
    (24) type4 -> .

    SEMICOL         reduce using rule 24 (type4 -> .)

    type4                          shift and go to state 102

state 79

    (41) let -> LET ID let1 COL type let2 IS var_b . SEMICOL let3

    SEMICOL         shift and go to state 103


state 80

    (32) var_b -> CTE_I . var4
    (38) var4 -> .

    SEMICOL         reduce using rule 38 (var4 -> .)

    var4                           shift and go to state 104

state 81

    (33) var_b -> CTE_F . var5
    (39) var5 -> .

    SEMICOL         reduce using rule 39 (var5 -> .)

    var5                           shift and go to state 105

state 82

    (34) var_b -> CTE_B . var6
    (40) var6 -> .

    SEMICOL         reduce using rule 40 (var6 -> .)

    var6                           shift and go to state 106

state 83

    (70) class_c -> init . class_c
    (70) class_c -> . init class_c
    (71) class_c -> . empty
    (75) init -> . INIT LP params RP block
    (143) empty -> .

    INIT            shift and go to state 67
    PRIVATE         reduce using rule 143 (empty -> .)
    RB              reduce using rule 143 (empty -> .)
    FUNCTION        reduce using rule 143 (empty -> .)

    init                           shift and go to state 83
    class_c                        shift and go to state 107
    empty                          shift and go to state 85

state 84

    (61) class -> CLASS ID class1 class_a LB class_b init class_c . class_d RB
    (72) class_d -> . class_e function class_d
    (73) class_d -> . empty
    (66) class_e -> . PRIVATE
    (67) class_e -> . empty
    (143) empty -> .

    PRIVATE         shift and go to state 54
    RB              reduce using rule 143 (empty -> .)
    FUNCTION        reduce using rule 143 (empty -> .)

    class_d                        shift and go to state 108
    class_e                        shift and go to state 109
    empty                          shift and go to state 110

state 85

    (71) class_c -> empty .

    PRIVATE         reduce using rule 71 (class_c -> empty .)
    RB              reduce using rule 71 (class_c -> empty .)
    FUNCTION        reduce using rule 71 (class_c -> empty .)


state 86

    (75) init -> INIT LP . params RP block
    (49) params -> . ID COL type params_a
    (50) params -> . empty
    (143) empty -> .

    ID              shift and go to state 56
    RP              reduce using rule 143 (empty -> .)

    params                         shift and go to state 111
    empty                          shift and go to state 58

state 87

    (64) class_b -> class_e class_f class_b .

    INIT            reduce using rule 64 (class_b -> class_e class_f class_b .)


state 88

    (56) function_block -> LB function_block_a . block_a RB
    (54) block_a -> . statement block_a
    (55) block_a -> . empty
    (76) statement -> . print
    (77) statement -> . input
    (78) statement -> . assignment
    (79) statement -> . condition
    (80) statement -> . loop
    (81) statement -> . call_function
    (82) statement -> . return
    (143) empty -> .
    (86) print -> . PRINT LP print_a RP SEMICOL
    (90) input -> . INPUT LP obj RP SEMICOL
    (85) assignment -> . obj IS expression SEMICOL
    (97) condition -> . IF expression block condition_a condition_b
    (91) loop -> . WHILE expression block
    (92) call_function -> . obj call_func SEMICOL
    (83) return -> . RETURN expression SEMICOL
    (84) obj -> . ID array attribute

    RB              reduce using rule 143 (empty -> .)
    PRINT           shift and go to state 122
    INPUT           shift and go to state 123
    IF              shift and go to state 125
    WHILE           shift and go to state 126
    RETURN          shift and go to state 127
    ID              shift and go to state 128

    block_a                        shift and go to state 112
    statement                      shift and go to state 113
    empty                          shift and go to state 114
    print                          shift and go to state 115
    input                          shift and go to state 116
    assignment                     shift and go to state 117
    condition                      shift and go to state 118
    loop                           shift and go to state 119
    call_function                  shift and go to state 120
    return                         shift and go to state 121
    obj                            shift and go to state 124

state 89

    (57) function_block_a -> function_block_b . function_block_a
    (57) function_block_a -> . function_block_b function_block_a
    (58) function_block_a -> . empty
    (59) function_block_b -> . var
    (60) function_block_b -> . let
    (143) empty -> .
    (28) var -> . VAR ID var1 COL type var2 var_a SEMICOL
    (29) var -> . VAR ID var1 COL typeM SEMICOL var2
    (41) let -> . LET ID let1 COL type let2 IS var_b SEMICOL let3

    PRINT           reduce using rule 143 (empty -> .)
    INPUT           reduce using rule 143 (empty -> .)
    IF              reduce using rule 143 (empty -> .)
    WHILE           reduce using rule 143 (empty -> .)
    RETURN          reduce using rule 143 (empty -> .)
    ID              reduce using rule 143 (empty -> .)
    RB              reduce using rule 143 (empty -> .)
    VAR             shift and go to state 19
    LET             shift and go to state 8

    function_block_b               shift and go to state 89
    function_block_a               shift and go to state 129
    empty                          shift and go to state 90
    var                            shift and go to state 91
    let                            shift and go to state 92

state 90

    (58) function_block_a -> empty .

    PRINT           reduce using rule 58 (function_block_a -> empty .)
    INPUT           reduce using rule 58 (function_block_a -> empty .)
    IF              reduce using rule 58 (function_block_a -> empty .)
    WHILE           reduce using rule 58 (function_block_a -> empty .)
    RETURN          reduce using rule 58 (function_block_a -> empty .)
    ID              reduce using rule 58 (function_block_a -> empty .)
    RB              reduce using rule 58 (function_block_a -> empty .)


state 91

    (59) function_block_b -> var .

    VAR             reduce using rule 59 (function_block_b -> var .)
    LET             reduce using rule 59 (function_block_b -> var .)
    PRINT           reduce using rule 59 (function_block_b -> var .)
    INPUT           reduce using rule 59 (function_block_b -> var .)
    IF              reduce using rule 59 (function_block_b -> var .)
    WHILE           reduce using rule 59 (function_block_b -> var .)
    RETURN          reduce using rule 59 (function_block_b -> var .)
    ID              reduce using rule 59 (function_block_b -> var .)
    RB              reduce using rule 59 (function_block_b -> var .)


state 92

    (60) function_block_b -> let .

    VAR             reduce using rule 60 (function_block_b -> let .)
    LET             reduce using rule 60 (function_block_b -> let .)
    PRINT           reduce using rule 60 (function_block_b -> let .)
    INPUT           reduce using rule 60 (function_block_b -> let .)
    IF              reduce using rule 60 (function_block_b -> let .)
    WHILE           reduce using rule 60 (function_block_b -> let .)
    RETURN          reduce using rule 60 (function_block_b -> let .)
    ID              reduce using rule 60 (function_block_b -> let .)
    RB              reduce using rule 60 (function_block_b -> let .)


state 93

    (49) params -> ID COL type . params_a
    (51) params_a -> . COMMA params
    (52) params_a -> . empty
    (143) empty -> .

    COMMA           shift and go to state 131
    RP              reduce using rule 143 (empty -> .)

    params_a                       shift and go to state 130
    empty                          shift and go to state 132

state 94

    (46) function -> FUNCTION ID LP params RP function_a . function_block
    (56) function_block -> . LB function_block_a block_a RB

    LB              shift and go to state 72

    function_block                 shift and go to state 133

state 95

    (47) function_a -> ARROW . type
    (16) type -> . type0 atomic
    (20) type0 -> .

    INT             reduce using rule 20 (type0 -> .)
    FLOAT           reduce using rule 20 (type0 -> .)
    BOOL            reduce using rule 20 (type0 -> .)

    type                           shift and go to state 134
    type0                          shift and go to state 39

state 96

    (48) function_a -> empty .

    LB              reduce using rule 48 (function_a -> empty .)


state 97

    (28) var -> VAR ID var1 COL type var2 var_a . SEMICOL

    SEMICOL         shift and go to state 135


state 98

    (30) var_a -> IS . var_b var3
    (32) var_b -> . CTE_I var4
    (33) var_b -> . CTE_F var5
    (34) var_b -> . CTE_B var6

    CTE_I           shift and go to state 80
    CTE_F           shift and go to state 81
    CTE_B           shift and go to state 82

    var_b                          shift and go to state 136

state 99

    (31) var_a -> empty .

    SEMICOL         reduce using rule 31 (var_a -> empty .)


state 100

    (29) var -> VAR ID var1 COL typeM SEMICOL var2 .

    VAR             reduce using rule 29 (var -> VAR ID var1 COL typeM SEMICOL var2 .)
    FUNCTION        reduce using rule 29 (var -> VAR ID var1 COL typeM SEMICOL var2 .)
    MAIN            reduce using rule 29 (var -> VAR ID var1 COL typeM SEMICOL var2 .)
    PRIVATE         reduce using rule 29 (var -> VAR ID var1 COL typeM SEMICOL var2 .)
    LET             reduce using rule 29 (var -> VAR ID var1 COL typeM SEMICOL var2 .)
    INIT            reduce using rule 29 (var -> VAR ID var1 COL typeM SEMICOL var2 .)
    PRINT           reduce using rule 29 (var -> VAR ID var1 COL typeM SEMICOL var2 .)
    INPUT           reduce using rule 29 (var -> VAR ID var1 COL typeM SEMICOL var2 .)
    IF              reduce using rule 29 (var -> VAR ID var1 COL typeM SEMICOL var2 .)
    WHILE           reduce using rule 29 (var -> VAR ID var1 COL typeM SEMICOL var2 .)
    RETURN          reduce using rule 29 (var -> VAR ID var1 COL typeM SEMICOL var2 .)
    ID              reduce using rule 29 (var -> VAR ID var1 COL typeM SEMICOL var2 .)
    RB              reduce using rule 29 (var -> VAR ID var1 COL typeM SEMICOL var2 .)


state 101

    (17) typeM -> type0 LC CTE_I . RC LC CTE_I RC atomic type1
    (18) typeM -> type0 LC CTE_I . RC atomic type2

    RC              shift and go to state 137


state 102

    (19) typeM -> type0 ID type4 .

    SEMICOL         reduce using rule 19 (typeM -> type0 ID type4 .)


state 103

    (41) let -> LET ID let1 COL type let2 IS var_b SEMICOL . let3
    (44) let3 -> .

    LET             reduce using rule 44 (let3 -> .)
    CLASS           reduce using rule 44 (let3 -> .)
    VAR             reduce using rule 44 (let3 -> .)
    FUNCTION        reduce using rule 44 (let3 -> .)
    MAIN            reduce using rule 44 (let3 -> .)
    PRIVATE         reduce using rule 44 (let3 -> .)
    INIT            reduce using rule 44 (let3 -> .)
    PRINT           reduce using rule 44 (let3 -> .)
    INPUT           reduce using rule 44 (let3 -> .)
    IF              reduce using rule 44 (let3 -> .)
    WHILE           reduce using rule 44 (let3 -> .)
    RETURN          reduce using rule 44 (let3 -> .)
    ID              reduce using rule 44 (let3 -> .)
    RB              reduce using rule 44 (let3 -> .)

    let3                           shift and go to state 138

state 104

    (32) var_b -> CTE_I var4 .

    SEMICOL         reduce using rule 32 (var_b -> CTE_I var4 .)


state 105

    (33) var_b -> CTE_F var5 .

    SEMICOL         reduce using rule 33 (var_b -> CTE_F var5 .)


state 106

    (34) var_b -> CTE_B var6 .

    SEMICOL         reduce using rule 34 (var_b -> CTE_B var6 .)


state 107

    (70) class_c -> init class_c .

    PRIVATE         reduce using rule 70 (class_c -> init class_c .)
    RB              reduce using rule 70 (class_c -> init class_c .)
    FUNCTION        reduce using rule 70 (class_c -> init class_c .)


state 108

    (61) class -> CLASS ID class1 class_a LB class_b init class_c class_d . RB

    RB              shift and go to state 139


state 109

    (72) class_d -> class_e . function class_d
    (46) function -> . FUNCTION ID LP params RP function_a function_block

    FUNCTION        shift and go to state 25

    function                       shift and go to state 140

state 110

    (73) class_d -> empty .
    (67) class_e -> empty .

    RB              reduce using rule 73 (class_d -> empty .)
    FUNCTION        reduce using rule 67 (class_e -> empty .)


state 111

    (75) init -> INIT LP params . RP block

    RP              shift and go to state 141


state 112

    (56) function_block -> LB function_block_a block_a . RB

    RB              shift and go to state 142


state 113

    (54) block_a -> statement . block_a
    (54) block_a -> . statement block_a
    (55) block_a -> . empty
    (76) statement -> . print
    (77) statement -> . input
    (78) statement -> . assignment
    (79) statement -> . condition
    (80) statement -> . loop
    (81) statement -> . call_function
    (82) statement -> . return
    (143) empty -> .
    (86) print -> . PRINT LP print_a RP SEMICOL
    (90) input -> . INPUT LP obj RP SEMICOL
    (85) assignment -> . obj IS expression SEMICOL
    (97) condition -> . IF expression block condition_a condition_b
    (91) loop -> . WHILE expression block
    (92) call_function -> . obj call_func SEMICOL
    (83) return -> . RETURN expression SEMICOL
    (84) obj -> . ID array attribute

    RB              reduce using rule 143 (empty -> .)
    PRINT           shift and go to state 122
    INPUT           shift and go to state 123
    IF              shift and go to state 125
    WHILE           shift and go to state 126
    RETURN          shift and go to state 127
    ID              shift and go to state 128

    statement                      shift and go to state 113
    block_a                        shift and go to state 143
    empty                          shift and go to state 114
    print                          shift and go to state 115
    input                          shift and go to state 116
    assignment                     shift and go to state 117
    condition                      shift and go to state 118
    loop                           shift and go to state 119
    call_function                  shift and go to state 120
    return                         shift and go to state 121
    obj                            shift and go to state 124

state 114

    (55) block_a -> empty .

    RB              reduce using rule 55 (block_a -> empty .)


state 115

    (76) statement -> print .

    PRINT           reduce using rule 76 (statement -> print .)
    INPUT           reduce using rule 76 (statement -> print .)
    IF              reduce using rule 76 (statement -> print .)
    WHILE           reduce using rule 76 (statement -> print .)
    RETURN          reduce using rule 76 (statement -> print .)
    ID              reduce using rule 76 (statement -> print .)
    RB              reduce using rule 76 (statement -> print .)


state 116

    (77) statement -> input .

    PRINT           reduce using rule 77 (statement -> input .)
    INPUT           reduce using rule 77 (statement -> input .)
    IF              reduce using rule 77 (statement -> input .)
    WHILE           reduce using rule 77 (statement -> input .)
    RETURN          reduce using rule 77 (statement -> input .)
    ID              reduce using rule 77 (statement -> input .)
    RB              reduce using rule 77 (statement -> input .)


state 117

    (78) statement -> assignment .

    PRINT           reduce using rule 78 (statement -> assignment .)
    INPUT           reduce using rule 78 (statement -> assignment .)
    IF              reduce using rule 78 (statement -> assignment .)
    WHILE           reduce using rule 78 (statement -> assignment .)
    RETURN          reduce using rule 78 (statement -> assignment .)
    ID              reduce using rule 78 (statement -> assignment .)
    RB              reduce using rule 78 (statement -> assignment .)


state 118

    (79) statement -> condition .

    PRINT           reduce using rule 79 (statement -> condition .)
    INPUT           reduce using rule 79 (statement -> condition .)
    IF              reduce using rule 79 (statement -> condition .)
    WHILE           reduce using rule 79 (statement -> condition .)
    RETURN          reduce using rule 79 (statement -> condition .)
    ID              reduce using rule 79 (statement -> condition .)
    RB              reduce using rule 79 (statement -> condition .)


state 119

    (80) statement -> loop .

    PRINT           reduce using rule 80 (statement -> loop .)
    INPUT           reduce using rule 80 (statement -> loop .)
    IF              reduce using rule 80 (statement -> loop .)
    WHILE           reduce using rule 80 (statement -> loop .)
    RETURN          reduce using rule 80 (statement -> loop .)
    ID              reduce using rule 80 (statement -> loop .)
    RB              reduce using rule 80 (statement -> loop .)


state 120

    (81) statement -> call_function .

    PRINT           reduce using rule 81 (statement -> call_function .)
    INPUT           reduce using rule 81 (statement -> call_function .)
    IF              reduce using rule 81 (statement -> call_function .)
    WHILE           reduce using rule 81 (statement -> call_function .)
    RETURN          reduce using rule 81 (statement -> call_function .)
    ID              reduce using rule 81 (statement -> call_function .)
    RB              reduce using rule 81 (statement -> call_function .)


state 121

    (82) statement -> return .

    PRINT           reduce using rule 82 (statement -> return .)
    INPUT           reduce using rule 82 (statement -> return .)
    IF              reduce using rule 82 (statement -> return .)
    WHILE           reduce using rule 82 (statement -> return .)
    RETURN          reduce using rule 82 (statement -> return .)
    ID              reduce using rule 82 (statement -> return .)
    RB              reduce using rule 82 (statement -> return .)


state 122

    (86) print -> PRINT . LP print_a RP SEMICOL

    LP              shift and go to state 144


state 123

    (90) input -> INPUT . LP obj RP SEMICOL

    LP              shift and go to state 145


state 124

    (85) assignment -> obj . IS expression SEMICOL
    (92) call_function -> obj . call_func SEMICOL
    (140) call_func -> . LP call_params RP

    IS              shift and go to state 146
    LP              shift and go to state 148

    call_func                      shift and go to state 147

state 125

    (97) condition -> IF . expression block condition_a condition_b
    (104) expression -> . comparison expression_a
    (108) comparison -> . exp comparison_a
    (117) exp -> . term exp_a
    (121) term -> . factor term_a
    (125) factor -> . LP expression RP
    (126) factor -> . factor_a var_cte
    (127) factor_a -> . MINUS
    (128) factor_a -> . NOT
    (129) factor_a -> . empty
    (143) empty -> .

    LP              shift and go to state 154
    MINUS           shift and go to state 156
    NOT             shift and go to state 157
    CTE_I           reduce using rule 143 (empty -> .)
    CTE_F           reduce using rule 143 (empty -> .)
    CTE_B           reduce using rule 143 (empty -> .)
    ID              reduce using rule 143 (empty -> .)

    expression                     shift and go to state 149
    comparison                     shift and go to state 150
    exp                            shift and go to state 151
    term                           shift and go to state 152
    factor                         shift and go to state 153
    factor_a                       shift and go to state 155
    empty                          shift and go to state 158

state 126

    (91) loop -> WHILE . expression block
    (104) expression -> . comparison expression_a
    (108) comparison -> . exp comparison_a
    (117) exp -> . term exp_a
    (121) term -> . factor term_a
    (125) factor -> . LP expression RP
    (126) factor -> . factor_a var_cte
    (127) factor_a -> . MINUS
    (128) factor_a -> . NOT
    (129) factor_a -> . empty
    (143) empty -> .

    LP              shift and go to state 154
    MINUS           shift and go to state 156
    NOT             shift and go to state 157
    CTE_I           reduce using rule 143 (empty -> .)
    CTE_F           reduce using rule 143 (empty -> .)
    CTE_B           reduce using rule 143 (empty -> .)
    ID              reduce using rule 143 (empty -> .)

    expression                     shift and go to state 159
    comparison                     shift and go to state 150
    exp                            shift and go to state 151
    term                           shift and go to state 152
    factor                         shift and go to state 153
    factor_a                       shift and go to state 155
    empty                          shift and go to state 158

state 127

    (83) return -> RETURN . expression SEMICOL
    (104) expression -> . comparison expression_a
    (108) comparison -> . exp comparison_a
    (117) exp -> . term exp_a
    (121) term -> . factor term_a
    (125) factor -> . LP expression RP
    (126) factor -> . factor_a var_cte
    (127) factor_a -> . MINUS
    (128) factor_a -> . NOT
    (129) factor_a -> . empty
    (143) empty -> .

    LP              shift and go to state 154
    MINUS           shift and go to state 156
    NOT             shift and go to state 157
    CTE_I           reduce using rule 143 (empty -> .)
    CTE_F           reduce using rule 143 (empty -> .)
    CTE_B           reduce using rule 143 (empty -> .)
    ID              reduce using rule 143 (empty -> .)

    expression                     shift and go to state 160
    comparison                     shift and go to state 150
    exp                            shift and go to state 151
    term                           shift and go to state 152
    factor                         shift and go to state 153
    factor_a                       shift and go to state 155
    empty                          shift and go to state 158

state 128

    (84) obj -> ID . array attribute
    (134) array -> . LC expression RC array_a
    (135) array -> . empty
    (143) empty -> .

    LC              shift and go to state 162
    DOT             reduce using rule 143 (empty -> .)
    IS              reduce using rule 143 (empty -> .)
    LP              reduce using rule 143 (empty -> .)
    RP              reduce using rule 143 (empty -> .)
    MUL             reduce using rule 143 (empty -> .)
    DIV             reduce using rule 143 (empty -> .)
    PLUS            reduce using rule 143 (empty -> .)
    MINUS           reduce using rule 143 (empty -> .)
    GEQ             reduce using rule 143 (empty -> .)
    LEQ             reduce using rule 143 (empty -> .)
    GT              reduce using rule 143 (empty -> .)
    LT              reduce using rule 143 (empty -> .)
    EQUAL           reduce using rule 143 (empty -> .)
    NEQ             reduce using rule 143 (empty -> .)
    AND             reduce using rule 143 (empty -> .)
    OR              reduce using rule 143 (empty -> .)
    LB              reduce using rule 143 (empty -> .)
    SEMICOL         reduce using rule 143 (empty -> .)
    COMMA           reduce using rule 143 (empty -> .)
    RC              reduce using rule 143 (empty -> .)

    array                          shift and go to state 161
    empty                          shift and go to state 163

state 129

    (57) function_block_a -> function_block_b function_block_a .

    PRINT           reduce using rule 57 (function_block_a -> function_block_b function_block_a .)
    INPUT           reduce using rule 57 (function_block_a -> function_block_b function_block_a .)
    IF              reduce using rule 57 (function_block_a -> function_block_b function_block_a .)
    WHILE           reduce using rule 57 (function_block_a -> function_block_b function_block_a .)
    RETURN          reduce using rule 57 (function_block_a -> function_block_b function_block_a .)
    ID              reduce using rule 57 (function_block_a -> function_block_b function_block_a .)
    RB              reduce using rule 57 (function_block_a -> function_block_b function_block_a .)


state 130

    (49) params -> ID COL type params_a .

    RP              reduce using rule 49 (params -> ID COL type params_a .)


state 131

    (51) params_a -> COMMA . params
    (49) params -> . ID COL type params_a
    (50) params -> . empty
    (143) empty -> .

    ID              shift and go to state 56
    RP              reduce using rule 143 (empty -> .)

    params                         shift and go to state 164
    empty                          shift and go to state 58

state 132

    (52) params_a -> empty .

    RP              reduce using rule 52 (params_a -> empty .)


state 133

    (46) function -> FUNCTION ID LP params RP function_a function_block .

    FUNCTION        reduce using rule 46 (function -> FUNCTION ID LP params RP function_a function_block .)
    MAIN            reduce using rule 46 (function -> FUNCTION ID LP params RP function_a function_block .)
    PRIVATE         reduce using rule 46 (function -> FUNCTION ID LP params RP function_a function_block .)
    RB              reduce using rule 46 (function -> FUNCTION ID LP params RP function_a function_block .)


state 134

    (47) function_a -> ARROW type .

    LB              reduce using rule 47 (function_a -> ARROW type .)


state 135

    (28) var -> VAR ID var1 COL type var2 var_a SEMICOL .

    VAR             reduce using rule 28 (var -> VAR ID var1 COL type var2 var_a SEMICOL .)
    FUNCTION        reduce using rule 28 (var -> VAR ID var1 COL type var2 var_a SEMICOL .)
    MAIN            reduce using rule 28 (var -> VAR ID var1 COL type var2 var_a SEMICOL .)
    PRIVATE         reduce using rule 28 (var -> VAR ID var1 COL type var2 var_a SEMICOL .)
    LET             reduce using rule 28 (var -> VAR ID var1 COL type var2 var_a SEMICOL .)
    INIT            reduce using rule 28 (var -> VAR ID var1 COL type var2 var_a SEMICOL .)
    PRINT           reduce using rule 28 (var -> VAR ID var1 COL type var2 var_a SEMICOL .)
    INPUT           reduce using rule 28 (var -> VAR ID var1 COL type var2 var_a SEMICOL .)
    IF              reduce using rule 28 (var -> VAR ID var1 COL type var2 var_a SEMICOL .)
    WHILE           reduce using rule 28 (var -> VAR ID var1 COL type var2 var_a SEMICOL .)
    RETURN          reduce using rule 28 (var -> VAR ID var1 COL type var2 var_a SEMICOL .)
    ID              reduce using rule 28 (var -> VAR ID var1 COL type var2 var_a SEMICOL .)
    RB              reduce using rule 28 (var -> VAR ID var1 COL type var2 var_a SEMICOL .)


state 136

    (30) var_a -> IS var_b . var3
    (37) var3 -> .

    SEMICOL         reduce using rule 37 (var3 -> .)

    var3                           shift and go to state 165

state 137

    (17) typeM -> type0 LC CTE_I RC . LC CTE_I RC atomic type1
    (18) typeM -> type0 LC CTE_I RC . atomic type2
    (25) atomic -> . INT type3
    (26) atomic -> . FLOAT type3
    (27) atomic -> . BOOL type3

    LC              shift and go to state 166
    INT             shift and go to state 48
    FLOAT           shift and go to state 49
    BOOL            shift and go to state 50

    atomic                         shift and go to state 167

state 138

    (41) let -> LET ID let1 COL type let2 IS var_b SEMICOL let3 .

    LET             reduce using rule 41 (let -> LET ID let1 COL type let2 IS var_b SEMICOL let3 .)
    CLASS           reduce using rule 41 (let -> LET ID let1 COL type let2 IS var_b SEMICOL let3 .)
    VAR             reduce using rule 41 (let -> LET ID let1 COL type let2 IS var_b SEMICOL let3 .)
    FUNCTION        reduce using rule 41 (let -> LET ID let1 COL type let2 IS var_b SEMICOL let3 .)
    MAIN            reduce using rule 41 (let -> LET ID let1 COL type let2 IS var_b SEMICOL let3 .)
    PRIVATE         reduce using rule 41 (let -> LET ID let1 COL type let2 IS var_b SEMICOL let3 .)
    INIT            reduce using rule 41 (let -> LET ID let1 COL type let2 IS var_b SEMICOL let3 .)
    PRINT           reduce using rule 41 (let -> LET ID let1 COL type let2 IS var_b SEMICOL let3 .)
    INPUT           reduce using rule 41 (let -> LET ID let1 COL type let2 IS var_b SEMICOL let3 .)
    IF              reduce using rule 41 (let -> LET ID let1 COL type let2 IS var_b SEMICOL let3 .)
    WHILE           reduce using rule 41 (let -> LET ID let1 COL type let2 IS var_b SEMICOL let3 .)
    RETURN          reduce using rule 41 (let -> LET ID let1 COL type let2 IS var_b SEMICOL let3 .)
    ID              reduce using rule 41 (let -> LET ID let1 COL type let2 IS var_b SEMICOL let3 .)
    RB              reduce using rule 41 (let -> LET ID let1 COL type let2 IS var_b SEMICOL let3 .)


state 139

    (61) class -> CLASS ID class1 class_a LB class_b init class_c class_d RB .

    LET             reduce using rule 61 (class -> CLASS ID class1 class_a LB class_b init class_c class_d RB .)
    CLASS           reduce using rule 61 (class -> CLASS ID class1 class_a LB class_b init class_c class_d RB .)
    VAR             reduce using rule 61 (class -> CLASS ID class1 class_a LB class_b init class_c class_d RB .)
    FUNCTION        reduce using rule 61 (class -> CLASS ID class1 class_a LB class_b init class_c class_d RB .)
    MAIN            reduce using rule 61 (class -> CLASS ID class1 class_a LB class_b init class_c class_d RB .)


state 140

    (72) class_d -> class_e function . class_d
    (72) class_d -> . class_e function class_d
    (73) class_d -> . empty
    (66) class_e -> . PRIVATE
    (67) class_e -> . empty
    (143) empty -> .

    PRIVATE         shift and go to state 54
    RB              reduce using rule 143 (empty -> .)
    FUNCTION        reduce using rule 143 (empty -> .)

    class_e                        shift and go to state 109
    class_d                        shift and go to state 168
    empty                          shift and go to state 110

state 141

    (75) init -> INIT LP params RP . block
    (53) block -> . LB block_a RB

    LB              shift and go to state 170

    block                          shift and go to state 169

state 142

    (56) function_block -> LB function_block_a block_a RB .

    $end            reduce using rule 56 (function_block -> LB function_block_a block_a RB .)
    FUNCTION        reduce using rule 56 (function_block -> LB function_block_a block_a RB .)
    MAIN            reduce using rule 56 (function_block -> LB function_block_a block_a RB .)
    PRIVATE         reduce using rule 56 (function_block -> LB function_block_a block_a RB .)
    RB              reduce using rule 56 (function_block -> LB function_block_a block_a RB .)


state 143

    (54) block_a -> statement block_a .

    RB              reduce using rule 54 (block_a -> statement block_a .)


state 144

    (86) print -> PRINT LP . print_a RP SEMICOL
    (87) print_a -> . expression
    (88) print_a -> . CTE_S
    (89) print_a -> . empty
    (104) expression -> . comparison expression_a
    (143) empty -> .
    (108) comparison -> . exp comparison_a
    (117) exp -> . term exp_a
    (121) term -> . factor term_a
    (125) factor -> . LP expression RP
    (126) factor -> . factor_a var_cte
    (127) factor_a -> . MINUS
    (128) factor_a -> . NOT
    (129) factor_a -> . empty

    CTE_S           shift and go to state 173
    RP              reduce using rule 143 (empty -> .)
    CTE_I           reduce using rule 143 (empty -> .)
    CTE_F           reduce using rule 143 (empty -> .)
    CTE_B           reduce using rule 143 (empty -> .)
    ID              reduce using rule 143 (empty -> .)
    LP              shift and go to state 154
    MINUS           shift and go to state 156
    NOT             shift and go to state 157

    print_a                        shift and go to state 171
    expression                     shift and go to state 172
    empty                          shift and go to state 174
    comparison                     shift and go to state 150
    exp                            shift and go to state 151
    term                           shift and go to state 152
    factor                         shift and go to state 153
    factor_a                       shift and go to state 155

state 145

    (90) input -> INPUT LP . obj RP SEMICOL
    (84) obj -> . ID array attribute

    ID              shift and go to state 128

    obj                            shift and go to state 175

state 146

    (85) assignment -> obj IS . expression SEMICOL
    (104) expression -> . comparison expression_a
    (108) comparison -> . exp comparison_a
    (117) exp -> . term exp_a
    (121) term -> . factor term_a
    (125) factor -> . LP expression RP
    (126) factor -> . factor_a var_cte
    (127) factor_a -> . MINUS
    (128) factor_a -> . NOT
    (129) factor_a -> . empty
    (143) empty -> .

    LP              shift and go to state 154
    MINUS           shift and go to state 156
    NOT             shift and go to state 157
    CTE_I           reduce using rule 143 (empty -> .)
    CTE_F           reduce using rule 143 (empty -> .)
    CTE_B           reduce using rule 143 (empty -> .)
    ID              reduce using rule 143 (empty -> .)

    expression                     shift and go to state 176
    comparison                     shift and go to state 150
    exp                            shift and go to state 151
    term                           shift and go to state 152
    factor                         shift and go to state 153
    factor_a                       shift and go to state 155
    empty                          shift and go to state 158

state 147

    (92) call_function -> obj call_func . SEMICOL

    SEMICOL         shift and go to state 177


state 148

    (140) call_func -> LP . call_params RP
    (93) call_params -> . expression call_params_a
    (94) call_params -> . empty
    (104) expression -> . comparison expression_a
    (143) empty -> .
    (108) comparison -> . exp comparison_a
    (117) exp -> . term exp_a
    (121) term -> . factor term_a
    (125) factor -> . LP expression RP
    (126) factor -> . factor_a var_cte
    (127) factor_a -> . MINUS
    (128) factor_a -> . NOT
    (129) factor_a -> . empty

    RP              reduce using rule 143 (empty -> .)
    CTE_I           reduce using rule 143 (empty -> .)
    CTE_F           reduce using rule 143 (empty -> .)
    CTE_B           reduce using rule 143 (empty -> .)
    ID              reduce using rule 143 (empty -> .)
    LP              shift and go to state 154
    MINUS           shift and go to state 156
    NOT             shift and go to state 157

    call_params                    shift and go to state 178
    expression                     shift and go to state 179
    empty                          shift and go to state 180
    comparison                     shift and go to state 150
    exp                            shift and go to state 151
    term                           shift and go to state 152
    factor                         shift and go to state 153
    factor_a                       shift and go to state 155

state 149

    (97) condition -> IF expression . block condition_a condition_b
    (53) block -> . LB block_a RB

    LB              shift and go to state 170

    block                          shift and go to state 181

state 150

    (104) expression -> comparison . expression_a
    (105) expression_a -> . AND comparison expression_a
    (106) expression_a -> . OR comparison
    (107) expression_a -> . empty
    (143) empty -> .

    AND             shift and go to state 183
    OR              shift and go to state 184
    LB              reduce using rule 143 (empty -> .)
    SEMICOL         reduce using rule 143 (empty -> .)
    RP              reduce using rule 143 (empty -> .)
    COMMA           reduce using rule 143 (empty -> .)
    RC              reduce using rule 143 (empty -> .)

    expression_a                   shift and go to state 182
    empty                          shift and go to state 185

state 151

    (108) comparison -> exp . comparison_a
    (109) comparison_a -> . comparison_b exp comparison_a
    (110) comparison_a -> . empty
    (111) comparison_b -> . GEQ
    (112) comparison_b -> . LEQ
    (113) comparison_b -> . GT
    (114) comparison_b -> . LT
    (115) comparison_b -> . EQUAL
    (116) comparison_b -> . NEQ
    (143) empty -> .

    GEQ             shift and go to state 189
    LEQ             shift and go to state 190
    GT              shift and go to state 191
    LT              shift and go to state 192
    EQUAL           shift and go to state 193
    NEQ             shift and go to state 194
    AND             reduce using rule 143 (empty -> .)
    OR              reduce using rule 143 (empty -> .)
    LB              reduce using rule 143 (empty -> .)
    SEMICOL         reduce using rule 143 (empty -> .)
    RP              reduce using rule 143 (empty -> .)
    COMMA           reduce using rule 143 (empty -> .)
    RC              reduce using rule 143 (empty -> .)

    comparison_a                   shift and go to state 186
    comparison_b                   shift and go to state 187
    empty                          shift and go to state 188

state 152

    (117) exp -> term . exp_a
    (118) exp_a -> . PLUS term exp_a
    (119) exp_a -> . MINUS term exp_a
    (120) exp_a -> . empty
    (143) empty -> .

    PLUS            shift and go to state 196
    MINUS           shift and go to state 197
    GEQ             reduce using rule 143 (empty -> .)
    LEQ             reduce using rule 143 (empty -> .)
    GT              reduce using rule 143 (empty -> .)
    LT              reduce using rule 143 (empty -> .)
    EQUAL           reduce using rule 143 (empty -> .)
    NEQ             reduce using rule 143 (empty -> .)
    AND             reduce using rule 143 (empty -> .)
    OR              reduce using rule 143 (empty -> .)
    LB              reduce using rule 143 (empty -> .)
    SEMICOL         reduce using rule 143 (empty -> .)
    RP              reduce using rule 143 (empty -> .)
    COMMA           reduce using rule 143 (empty -> .)
    RC              reduce using rule 143 (empty -> .)

    exp_a                          shift and go to state 195
    empty                          shift and go to state 198

state 153

    (121) term -> factor . term_a
    (122) term_a -> . MUL factor term_a
    (123) term_a -> . DIV factor term_a
    (124) term_a -> . empty
    (143) empty -> .

    MUL             shift and go to state 200
    DIV             shift and go to state 201
    PLUS            reduce using rule 143 (empty -> .)
    MINUS           reduce using rule 143 (empty -> .)
    GEQ             reduce using rule 143 (empty -> .)
    LEQ             reduce using rule 143 (empty -> .)
    GT              reduce using rule 143 (empty -> .)
    LT              reduce using rule 143 (empty -> .)
    EQUAL           reduce using rule 143 (empty -> .)
    NEQ             reduce using rule 143 (empty -> .)
    AND             reduce using rule 143 (empty -> .)
    OR              reduce using rule 143 (empty -> .)
    LB              reduce using rule 143 (empty -> .)
    SEMICOL         reduce using rule 143 (empty -> .)
    RP              reduce using rule 143 (empty -> .)
    COMMA           reduce using rule 143 (empty -> .)
    RC              reduce using rule 143 (empty -> .)

    term_a                         shift and go to state 199
    empty                          shift and go to state 202

state 154

    (125) factor -> LP . expression RP
    (104) expression -> . comparison expression_a
    (108) comparison -> . exp comparison_a
    (117) exp -> . term exp_a
    (121) term -> . factor term_a
    (125) factor -> . LP expression RP
    (126) factor -> . factor_a var_cte
    (127) factor_a -> . MINUS
    (128) factor_a -> . NOT
    (129) factor_a -> . empty
    (143) empty -> .

    LP              shift and go to state 154
    MINUS           shift and go to state 156
    NOT             shift and go to state 157
    CTE_I           reduce using rule 143 (empty -> .)
    CTE_F           reduce using rule 143 (empty -> .)
    CTE_B           reduce using rule 143 (empty -> .)
    ID              reduce using rule 143 (empty -> .)

    expression                     shift and go to state 203
    comparison                     shift and go to state 150
    exp                            shift and go to state 151
    term                           shift and go to state 152
    factor                         shift and go to state 153
    factor_a                       shift and go to state 155
    empty                          shift and go to state 158

state 155

    (126) factor -> factor_a . var_cte
    (130) var_cte -> . obj call_func_optional
    (131) var_cte -> . CTE_I
    (132) var_cte -> . CTE_F
    (133) var_cte -> . CTE_B
    (84) obj -> . ID array attribute

    CTE_I           shift and go to state 206
    CTE_F           shift and go to state 207
    CTE_B           shift and go to state 208
    ID              shift and go to state 128

    var_cte                        shift and go to state 204
    obj                            shift and go to state 205

state 156

    (127) factor_a -> MINUS .

    CTE_I           reduce using rule 127 (factor_a -> MINUS .)
    CTE_F           reduce using rule 127 (factor_a -> MINUS .)
    CTE_B           reduce using rule 127 (factor_a -> MINUS .)
    ID              reduce using rule 127 (factor_a -> MINUS .)


state 157

    (128) factor_a -> NOT .

    CTE_I           reduce using rule 128 (factor_a -> NOT .)
    CTE_F           reduce using rule 128 (factor_a -> NOT .)
    CTE_B           reduce using rule 128 (factor_a -> NOT .)
    ID              reduce using rule 128 (factor_a -> NOT .)


state 158

    (129) factor_a -> empty .

    CTE_I           reduce using rule 129 (factor_a -> empty .)
    CTE_F           reduce using rule 129 (factor_a -> empty .)
    CTE_B           reduce using rule 129 (factor_a -> empty .)
    ID              reduce using rule 129 (factor_a -> empty .)


state 159

    (91) loop -> WHILE expression . block
    (53) block -> . LB block_a RB

    LB              shift and go to state 170

    block                          shift and go to state 209

state 160

    (83) return -> RETURN expression . SEMICOL

    SEMICOL         shift and go to state 210


state 161

    (84) obj -> ID array . attribute
    (138) attribute -> . DOT ID
    (139) attribute -> . empty
    (143) empty -> .

    DOT             shift and go to state 212
    IS              reduce using rule 143 (empty -> .)
    LP              reduce using rule 143 (empty -> .)
    RP              reduce using rule 143 (empty -> .)
    MUL             reduce using rule 143 (empty -> .)
    DIV             reduce using rule 143 (empty -> .)
    PLUS            reduce using rule 143 (empty -> .)
    MINUS           reduce using rule 143 (empty -> .)
    GEQ             reduce using rule 143 (empty -> .)
    LEQ             reduce using rule 143 (empty -> .)
    GT              reduce using rule 143 (empty -> .)
    LT              reduce using rule 143 (empty -> .)
    EQUAL           reduce using rule 143 (empty -> .)
    NEQ             reduce using rule 143 (empty -> .)
    AND             reduce using rule 143 (empty -> .)
    OR              reduce using rule 143 (empty -> .)
    LB              reduce using rule 143 (empty -> .)
    SEMICOL         reduce using rule 143 (empty -> .)
    COMMA           reduce using rule 143 (empty -> .)
    RC              reduce using rule 143 (empty -> .)

    attribute                      shift and go to state 211
    empty                          shift and go to state 213

state 162

    (134) array -> LC . expression RC array_a
    (104) expression -> . comparison expression_a
    (108) comparison -> . exp comparison_a
    (117) exp -> . term exp_a
    (121) term -> . factor term_a
    (125) factor -> . LP expression RP
    (126) factor -> . factor_a var_cte
    (127) factor_a -> . MINUS
    (128) factor_a -> . NOT
    (129) factor_a -> . empty
    (143) empty -> .

    LP              shift and go to state 154
    MINUS           shift and go to state 156
    NOT             shift and go to state 157
    CTE_I           reduce using rule 143 (empty -> .)
    CTE_F           reduce using rule 143 (empty -> .)
    CTE_B           reduce using rule 143 (empty -> .)
    ID              reduce using rule 143 (empty -> .)

    expression                     shift and go to state 214
    comparison                     shift and go to state 150
    exp                            shift and go to state 151
    term                           shift and go to state 152
    factor                         shift and go to state 153
    factor_a                       shift and go to state 155
    empty                          shift and go to state 158

state 163

    (135) array -> empty .

    DOT             reduce using rule 135 (array -> empty .)
    IS              reduce using rule 135 (array -> empty .)
    LP              reduce using rule 135 (array -> empty .)
    RP              reduce using rule 135 (array -> empty .)
    MUL             reduce using rule 135 (array -> empty .)
    DIV             reduce using rule 135 (array -> empty .)
    PLUS            reduce using rule 135 (array -> empty .)
    MINUS           reduce using rule 135 (array -> empty .)
    GEQ             reduce using rule 135 (array -> empty .)
    LEQ             reduce using rule 135 (array -> empty .)
    GT              reduce using rule 135 (array -> empty .)
    LT              reduce using rule 135 (array -> empty .)
    EQUAL           reduce using rule 135 (array -> empty .)
    NEQ             reduce using rule 135 (array -> empty .)
    AND             reduce using rule 135 (array -> empty .)
    OR              reduce using rule 135 (array -> empty .)
    LB              reduce using rule 135 (array -> empty .)
    SEMICOL         reduce using rule 135 (array -> empty .)
    COMMA           reduce using rule 135 (array -> empty .)
    RC              reduce using rule 135 (array -> empty .)


state 164

    (51) params_a -> COMMA params .

    RP              reduce using rule 51 (params_a -> COMMA params .)


state 165

    (30) var_a -> IS var_b var3 .

    SEMICOL         reduce using rule 30 (var_a -> IS var_b var3 .)


state 166

    (17) typeM -> type0 LC CTE_I RC LC . CTE_I RC atomic type1

    CTE_I           shift and go to state 215


state 167

    (18) typeM -> type0 LC CTE_I RC atomic . type2
    (22) type2 -> .

    SEMICOL         reduce using rule 22 (type2 -> .)

    type2                          shift and go to state 216

state 168

    (72) class_d -> class_e function class_d .

    RB              reduce using rule 72 (class_d -> class_e function class_d .)


state 169

    (75) init -> INIT LP params RP block .

    INIT            reduce using rule 75 (init -> INIT LP params RP block .)
    PRIVATE         reduce using rule 75 (init -> INIT LP params RP block .)
    RB              reduce using rule 75 (init -> INIT LP params RP block .)
    FUNCTION        reduce using rule 75 (init -> INIT LP params RP block .)


state 170

    (53) block -> LB . block_a RB
    (54) block_a -> . statement block_a
    (55) block_a -> . empty
    (76) statement -> . print
    (77) statement -> . input
    (78) statement -> . assignment
    (79) statement -> . condition
    (80) statement -> . loop
    (81) statement -> . call_function
    (82) statement -> . return
    (143) empty -> .
    (86) print -> . PRINT LP print_a RP SEMICOL
    (90) input -> . INPUT LP obj RP SEMICOL
    (85) assignment -> . obj IS expression SEMICOL
    (97) condition -> . IF expression block condition_a condition_b
    (91) loop -> . WHILE expression block
    (92) call_function -> . obj call_func SEMICOL
    (83) return -> . RETURN expression SEMICOL
    (84) obj -> . ID array attribute

    RB              reduce using rule 143 (empty -> .)
    PRINT           shift and go to state 122
    INPUT           shift and go to state 123
    IF              shift and go to state 125
    WHILE           shift and go to state 126
    RETURN          shift and go to state 127
    ID              shift and go to state 128

    block_a                        shift and go to state 217
    statement                      shift and go to state 113
    empty                          shift and go to state 114
    print                          shift and go to state 115
    input                          shift and go to state 116
    assignment                     shift and go to state 117
    condition                      shift and go to state 118
    loop                           shift and go to state 119
    call_function                  shift and go to state 120
    return                         shift and go to state 121
    obj                            shift and go to state 124

state 171

    (86) print -> PRINT LP print_a . RP SEMICOL

    RP              shift and go to state 218


state 172

    (87) print_a -> expression .

    RP              reduce using rule 87 (print_a -> expression .)


state 173

    (88) print_a -> CTE_S .

    RP              reduce using rule 88 (print_a -> CTE_S .)


state 174

    (89) print_a -> empty .
    (129) factor_a -> empty .

    RP              reduce using rule 89 (print_a -> empty .)
    CTE_I           reduce using rule 129 (factor_a -> empty .)
    CTE_F           reduce using rule 129 (factor_a -> empty .)
    CTE_B           reduce using rule 129 (factor_a -> empty .)
    ID              reduce using rule 129 (factor_a -> empty .)


state 175

    (90) input -> INPUT LP obj . RP SEMICOL

    RP              shift and go to state 219


state 176

    (85) assignment -> obj IS expression . SEMICOL

    SEMICOL         shift and go to state 220


state 177

    (92) call_function -> obj call_func SEMICOL .

    PRINT           reduce using rule 92 (call_function -> obj call_func SEMICOL .)
    INPUT           reduce using rule 92 (call_function -> obj call_func SEMICOL .)
    IF              reduce using rule 92 (call_function -> obj call_func SEMICOL .)
    WHILE           reduce using rule 92 (call_function -> obj call_func SEMICOL .)
    RETURN          reduce using rule 92 (call_function -> obj call_func SEMICOL .)
    ID              reduce using rule 92 (call_function -> obj call_func SEMICOL .)
    RB              reduce using rule 92 (call_function -> obj call_func SEMICOL .)


state 178

    (140) call_func -> LP call_params . RP

    RP              shift and go to state 221


state 179

    (93) call_params -> expression . call_params_a
    (95) call_params_a -> . COMMA expression call_params_a
    (96) call_params_a -> . empty
    (143) empty -> .

    COMMA           shift and go to state 223
    RP              reduce using rule 143 (empty -> .)

    call_params_a                  shift and go to state 222
    empty                          shift and go to state 224

state 180

    (94) call_params -> empty .
    (129) factor_a -> empty .

    RP              reduce using rule 94 (call_params -> empty .)
    CTE_I           reduce using rule 129 (factor_a -> empty .)
    CTE_F           reduce using rule 129 (factor_a -> empty .)
    CTE_B           reduce using rule 129 (factor_a -> empty .)
    ID              reduce using rule 129 (factor_a -> empty .)


state 181

    (97) condition -> IF expression block . condition_a condition_b
    (98) condition_a -> . elseif condition_a
    (99) condition_a -> . empty
    (102) elseif -> . ELSEIF expression block
    (143) empty -> .

    ELSEIF          shift and go to state 228
    ELSE            reduce using rule 143 (empty -> .)
    PRINT           reduce using rule 143 (empty -> .)
    INPUT           reduce using rule 143 (empty -> .)
    IF              reduce using rule 143 (empty -> .)
    WHILE           reduce using rule 143 (empty -> .)
    RETURN          reduce using rule 143 (empty -> .)
    ID              reduce using rule 143 (empty -> .)
    RB              reduce using rule 143 (empty -> .)

    condition_a                    shift and go to state 225
    elseif                         shift and go to state 226
    empty                          shift and go to state 227

state 182

    (104) expression -> comparison expression_a .

    LB              reduce using rule 104 (expression -> comparison expression_a .)
    SEMICOL         reduce using rule 104 (expression -> comparison expression_a .)
    RP              reduce using rule 104 (expression -> comparison expression_a .)
    COMMA           reduce using rule 104 (expression -> comparison expression_a .)
    RC              reduce using rule 104 (expression -> comparison expression_a .)


state 183

    (105) expression_a -> AND . comparison expression_a
    (108) comparison -> . exp comparison_a
    (117) exp -> . term exp_a
    (121) term -> . factor term_a
    (125) factor -> . LP expression RP
    (126) factor -> . factor_a var_cte
    (127) factor_a -> . MINUS
    (128) factor_a -> . NOT
    (129) factor_a -> . empty
    (143) empty -> .

    LP              shift and go to state 154
    MINUS           shift and go to state 156
    NOT             shift and go to state 157
    CTE_I           reduce using rule 143 (empty -> .)
    CTE_F           reduce using rule 143 (empty -> .)
    CTE_B           reduce using rule 143 (empty -> .)
    ID              reduce using rule 143 (empty -> .)

    comparison                     shift and go to state 229
    exp                            shift and go to state 151
    term                           shift and go to state 152
    factor                         shift and go to state 153
    factor_a                       shift and go to state 155
    empty                          shift and go to state 158

state 184

    (106) expression_a -> OR . comparison
    (108) comparison -> . exp comparison_a
    (117) exp -> . term exp_a
    (121) term -> . factor term_a
    (125) factor -> . LP expression RP
    (126) factor -> . factor_a var_cte
    (127) factor_a -> . MINUS
    (128) factor_a -> . NOT
    (129) factor_a -> . empty
    (143) empty -> .

    LP              shift and go to state 154
    MINUS           shift and go to state 156
    NOT             shift and go to state 157
    CTE_I           reduce using rule 143 (empty -> .)
    CTE_F           reduce using rule 143 (empty -> .)
    CTE_B           reduce using rule 143 (empty -> .)
    ID              reduce using rule 143 (empty -> .)

    comparison                     shift and go to state 230
    exp                            shift and go to state 151
    term                           shift and go to state 152
    factor                         shift and go to state 153
    factor_a                       shift and go to state 155
    empty                          shift and go to state 158

state 185

    (107) expression_a -> empty .

    LB              reduce using rule 107 (expression_a -> empty .)
    SEMICOL         reduce using rule 107 (expression_a -> empty .)
    RP              reduce using rule 107 (expression_a -> empty .)
    COMMA           reduce using rule 107 (expression_a -> empty .)
    RC              reduce using rule 107 (expression_a -> empty .)


state 186

    (108) comparison -> exp comparison_a .

    AND             reduce using rule 108 (comparison -> exp comparison_a .)
    OR              reduce using rule 108 (comparison -> exp comparison_a .)
    LB              reduce using rule 108 (comparison -> exp comparison_a .)
    SEMICOL         reduce using rule 108 (comparison -> exp comparison_a .)
    RP              reduce using rule 108 (comparison -> exp comparison_a .)
    COMMA           reduce using rule 108 (comparison -> exp comparison_a .)
    RC              reduce using rule 108 (comparison -> exp comparison_a .)


state 187

    (109) comparison_a -> comparison_b . exp comparison_a
    (117) exp -> . term exp_a
    (121) term -> . factor term_a
    (125) factor -> . LP expression RP
    (126) factor -> . factor_a var_cte
    (127) factor_a -> . MINUS
    (128) factor_a -> . NOT
    (129) factor_a -> . empty
    (143) empty -> .

    LP              shift and go to state 154
    MINUS           shift and go to state 156
    NOT             shift and go to state 157
    CTE_I           reduce using rule 143 (empty -> .)
    CTE_F           reduce using rule 143 (empty -> .)
    CTE_B           reduce using rule 143 (empty -> .)
    ID              reduce using rule 143 (empty -> .)

    exp                            shift and go to state 231
    term                           shift and go to state 152
    factor                         shift and go to state 153
    factor_a                       shift and go to state 155
    empty                          shift and go to state 158

state 188

    (110) comparison_a -> empty .

    AND             reduce using rule 110 (comparison_a -> empty .)
    OR              reduce using rule 110 (comparison_a -> empty .)
    LB              reduce using rule 110 (comparison_a -> empty .)
    SEMICOL         reduce using rule 110 (comparison_a -> empty .)
    RP              reduce using rule 110 (comparison_a -> empty .)
    COMMA           reduce using rule 110 (comparison_a -> empty .)
    RC              reduce using rule 110 (comparison_a -> empty .)


state 189

    (111) comparison_b -> GEQ .

    LP              reduce using rule 111 (comparison_b -> GEQ .)
    MINUS           reduce using rule 111 (comparison_b -> GEQ .)
    NOT             reduce using rule 111 (comparison_b -> GEQ .)
    CTE_I           reduce using rule 111 (comparison_b -> GEQ .)
    CTE_F           reduce using rule 111 (comparison_b -> GEQ .)
    CTE_B           reduce using rule 111 (comparison_b -> GEQ .)
    ID              reduce using rule 111 (comparison_b -> GEQ .)


state 190

    (112) comparison_b -> LEQ .

    LP              reduce using rule 112 (comparison_b -> LEQ .)
    MINUS           reduce using rule 112 (comparison_b -> LEQ .)
    NOT             reduce using rule 112 (comparison_b -> LEQ .)
    CTE_I           reduce using rule 112 (comparison_b -> LEQ .)
    CTE_F           reduce using rule 112 (comparison_b -> LEQ .)
    CTE_B           reduce using rule 112 (comparison_b -> LEQ .)
    ID              reduce using rule 112 (comparison_b -> LEQ .)


state 191

    (113) comparison_b -> GT .

    LP              reduce using rule 113 (comparison_b -> GT .)
    MINUS           reduce using rule 113 (comparison_b -> GT .)
    NOT             reduce using rule 113 (comparison_b -> GT .)
    CTE_I           reduce using rule 113 (comparison_b -> GT .)
    CTE_F           reduce using rule 113 (comparison_b -> GT .)
    CTE_B           reduce using rule 113 (comparison_b -> GT .)
    ID              reduce using rule 113 (comparison_b -> GT .)


state 192

    (114) comparison_b -> LT .

    LP              reduce using rule 114 (comparison_b -> LT .)
    MINUS           reduce using rule 114 (comparison_b -> LT .)
    NOT             reduce using rule 114 (comparison_b -> LT .)
    CTE_I           reduce using rule 114 (comparison_b -> LT .)
    CTE_F           reduce using rule 114 (comparison_b -> LT .)
    CTE_B           reduce using rule 114 (comparison_b -> LT .)
    ID              reduce using rule 114 (comparison_b -> LT .)


state 193

    (115) comparison_b -> EQUAL .

    LP              reduce using rule 115 (comparison_b -> EQUAL .)
    MINUS           reduce using rule 115 (comparison_b -> EQUAL .)
    NOT             reduce using rule 115 (comparison_b -> EQUAL .)
    CTE_I           reduce using rule 115 (comparison_b -> EQUAL .)
    CTE_F           reduce using rule 115 (comparison_b -> EQUAL .)
    CTE_B           reduce using rule 115 (comparison_b -> EQUAL .)
    ID              reduce using rule 115 (comparison_b -> EQUAL .)


state 194

    (116) comparison_b -> NEQ .

    LP              reduce using rule 116 (comparison_b -> NEQ .)
    MINUS           reduce using rule 116 (comparison_b -> NEQ .)
    NOT             reduce using rule 116 (comparison_b -> NEQ .)
    CTE_I           reduce using rule 116 (comparison_b -> NEQ .)
    CTE_F           reduce using rule 116 (comparison_b -> NEQ .)
    CTE_B           reduce using rule 116 (comparison_b -> NEQ .)
    ID              reduce using rule 116 (comparison_b -> NEQ .)


state 195

    (117) exp -> term exp_a .

    GEQ             reduce using rule 117 (exp -> term exp_a .)
    LEQ             reduce using rule 117 (exp -> term exp_a .)
    GT              reduce using rule 117 (exp -> term exp_a .)
    LT              reduce using rule 117 (exp -> term exp_a .)
    EQUAL           reduce using rule 117 (exp -> term exp_a .)
    NEQ             reduce using rule 117 (exp -> term exp_a .)
    AND             reduce using rule 117 (exp -> term exp_a .)
    OR              reduce using rule 117 (exp -> term exp_a .)
    LB              reduce using rule 117 (exp -> term exp_a .)
    SEMICOL         reduce using rule 117 (exp -> term exp_a .)
    RP              reduce using rule 117 (exp -> term exp_a .)
    COMMA           reduce using rule 117 (exp -> term exp_a .)
    RC              reduce using rule 117 (exp -> term exp_a .)


state 196

    (118) exp_a -> PLUS . term exp_a
    (121) term -> . factor term_a
    (125) factor -> . LP expression RP
    (126) factor -> . factor_a var_cte
    (127) factor_a -> . MINUS
    (128) factor_a -> . NOT
    (129) factor_a -> . empty
    (143) empty -> .

    LP              shift and go to state 154
    MINUS           shift and go to state 156
    NOT             shift and go to state 157
    CTE_I           reduce using rule 143 (empty -> .)
    CTE_F           reduce using rule 143 (empty -> .)
    CTE_B           reduce using rule 143 (empty -> .)
    ID              reduce using rule 143 (empty -> .)

    term                           shift and go to state 232
    factor                         shift and go to state 153
    factor_a                       shift and go to state 155
    empty                          shift and go to state 158

state 197

    (119) exp_a -> MINUS . term exp_a
    (121) term -> . factor term_a
    (125) factor -> . LP expression RP
    (126) factor -> . factor_a var_cte
    (127) factor_a -> . MINUS
    (128) factor_a -> . NOT
    (129) factor_a -> . empty
    (143) empty -> .

    LP              shift and go to state 154
    MINUS           shift and go to state 156
    NOT             shift and go to state 157
    CTE_I           reduce using rule 143 (empty -> .)
    CTE_F           reduce using rule 143 (empty -> .)
    CTE_B           reduce using rule 143 (empty -> .)
    ID              reduce using rule 143 (empty -> .)

    term                           shift and go to state 233
    factor                         shift and go to state 153
    factor_a                       shift and go to state 155
    empty                          shift and go to state 158

state 198

    (120) exp_a -> empty .

    GEQ             reduce using rule 120 (exp_a -> empty .)
    LEQ             reduce using rule 120 (exp_a -> empty .)
    GT              reduce using rule 120 (exp_a -> empty .)
    LT              reduce using rule 120 (exp_a -> empty .)
    EQUAL           reduce using rule 120 (exp_a -> empty .)
    NEQ             reduce using rule 120 (exp_a -> empty .)
    AND             reduce using rule 120 (exp_a -> empty .)
    OR              reduce using rule 120 (exp_a -> empty .)
    LB              reduce using rule 120 (exp_a -> empty .)
    SEMICOL         reduce using rule 120 (exp_a -> empty .)
    RP              reduce using rule 120 (exp_a -> empty .)
    COMMA           reduce using rule 120 (exp_a -> empty .)
    RC              reduce using rule 120 (exp_a -> empty .)


state 199

    (121) term -> factor term_a .

    PLUS            reduce using rule 121 (term -> factor term_a .)
    MINUS           reduce using rule 121 (term -> factor term_a .)
    GEQ             reduce using rule 121 (term -> factor term_a .)
    LEQ             reduce using rule 121 (term -> factor term_a .)
    GT              reduce using rule 121 (term -> factor term_a .)
    LT              reduce using rule 121 (term -> factor term_a .)
    EQUAL           reduce using rule 121 (term -> factor term_a .)
    NEQ             reduce using rule 121 (term -> factor term_a .)
    AND             reduce using rule 121 (term -> factor term_a .)
    OR              reduce using rule 121 (term -> factor term_a .)
    LB              reduce using rule 121 (term -> factor term_a .)
    SEMICOL         reduce using rule 121 (term -> factor term_a .)
    RP              reduce using rule 121 (term -> factor term_a .)
    COMMA           reduce using rule 121 (term -> factor term_a .)
    RC              reduce using rule 121 (term -> factor term_a .)


state 200

    (122) term_a -> MUL . factor term_a
    (125) factor -> . LP expression RP
    (126) factor -> . factor_a var_cte
    (127) factor_a -> . MINUS
    (128) factor_a -> . NOT
    (129) factor_a -> . empty
    (143) empty -> .

    LP              shift and go to state 154
    MINUS           shift and go to state 156
    NOT             shift and go to state 157
    CTE_I           reduce using rule 143 (empty -> .)
    CTE_F           reduce using rule 143 (empty -> .)
    CTE_B           reduce using rule 143 (empty -> .)
    ID              reduce using rule 143 (empty -> .)

    factor                         shift and go to state 234
    factor_a                       shift and go to state 155
    empty                          shift and go to state 158

state 201

    (123) term_a -> DIV . factor term_a
    (125) factor -> . LP expression RP
    (126) factor -> . factor_a var_cte
    (127) factor_a -> . MINUS
    (128) factor_a -> . NOT
    (129) factor_a -> . empty
    (143) empty -> .

    LP              shift and go to state 154
    MINUS           shift and go to state 156
    NOT             shift and go to state 157
    CTE_I           reduce using rule 143 (empty -> .)
    CTE_F           reduce using rule 143 (empty -> .)
    CTE_B           reduce using rule 143 (empty -> .)
    ID              reduce using rule 143 (empty -> .)

    factor                         shift and go to state 235
    factor_a                       shift and go to state 155
    empty                          shift and go to state 158

state 202

    (124) term_a -> empty .

    PLUS            reduce using rule 124 (term_a -> empty .)
    MINUS           reduce using rule 124 (term_a -> empty .)
    GEQ             reduce using rule 124 (term_a -> empty .)
    LEQ             reduce using rule 124 (term_a -> empty .)
    GT              reduce using rule 124 (term_a -> empty .)
    LT              reduce using rule 124 (term_a -> empty .)
    EQUAL           reduce using rule 124 (term_a -> empty .)
    NEQ             reduce using rule 124 (term_a -> empty .)
    AND             reduce using rule 124 (term_a -> empty .)
    OR              reduce using rule 124 (term_a -> empty .)
    LB              reduce using rule 124 (term_a -> empty .)
    SEMICOL         reduce using rule 124 (term_a -> empty .)
    RP              reduce using rule 124 (term_a -> empty .)
    COMMA           reduce using rule 124 (term_a -> empty .)
    RC              reduce using rule 124 (term_a -> empty .)


state 203

    (125) factor -> LP expression . RP

    RP              shift and go to state 236


state 204

    (126) factor -> factor_a var_cte .

    MUL             reduce using rule 126 (factor -> factor_a var_cte .)
    DIV             reduce using rule 126 (factor -> factor_a var_cte .)
    PLUS            reduce using rule 126 (factor -> factor_a var_cte .)
    MINUS           reduce using rule 126 (factor -> factor_a var_cte .)
    GEQ             reduce using rule 126 (factor -> factor_a var_cte .)
    LEQ             reduce using rule 126 (factor -> factor_a var_cte .)
    GT              reduce using rule 126 (factor -> factor_a var_cte .)
    LT              reduce using rule 126 (factor -> factor_a var_cte .)
    EQUAL           reduce using rule 126 (factor -> factor_a var_cte .)
    NEQ             reduce using rule 126 (factor -> factor_a var_cte .)
    AND             reduce using rule 126 (factor -> factor_a var_cte .)
    OR              reduce using rule 126 (factor -> factor_a var_cte .)
    LB              reduce using rule 126 (factor -> factor_a var_cte .)
    SEMICOL         reduce using rule 126 (factor -> factor_a var_cte .)
    RP              reduce using rule 126 (factor -> factor_a var_cte .)
    COMMA           reduce using rule 126 (factor -> factor_a var_cte .)
    RC              reduce using rule 126 (factor -> factor_a var_cte .)


state 205

    (130) var_cte -> obj . call_func_optional
    (141) call_func_optional -> . call_func
    (142) call_func_optional -> . empty
    (140) call_func -> . LP call_params RP
    (143) empty -> .

    LP              shift and go to state 148
    MUL             reduce using rule 143 (empty -> .)
    DIV             reduce using rule 143 (empty -> .)
    PLUS            reduce using rule 143 (empty -> .)
    MINUS           reduce using rule 143 (empty -> .)
    GEQ             reduce using rule 143 (empty -> .)
    LEQ             reduce using rule 143 (empty -> .)
    GT              reduce using rule 143 (empty -> .)
    LT              reduce using rule 143 (empty -> .)
    EQUAL           reduce using rule 143 (empty -> .)
    NEQ             reduce using rule 143 (empty -> .)
    AND             reduce using rule 143 (empty -> .)
    OR              reduce using rule 143 (empty -> .)
    LB              reduce using rule 143 (empty -> .)
    SEMICOL         reduce using rule 143 (empty -> .)
    RP              reduce using rule 143 (empty -> .)
    COMMA           reduce using rule 143 (empty -> .)
    RC              reduce using rule 143 (empty -> .)

    call_func_optional             shift and go to state 237
    call_func                      shift and go to state 238
    empty                          shift and go to state 239

state 206

    (131) var_cte -> CTE_I .

    MUL             reduce using rule 131 (var_cte -> CTE_I .)
    DIV             reduce using rule 131 (var_cte -> CTE_I .)
    PLUS            reduce using rule 131 (var_cte -> CTE_I .)
    MINUS           reduce using rule 131 (var_cte -> CTE_I .)
    GEQ             reduce using rule 131 (var_cte -> CTE_I .)
    LEQ             reduce using rule 131 (var_cte -> CTE_I .)
    GT              reduce using rule 131 (var_cte -> CTE_I .)
    LT              reduce using rule 131 (var_cte -> CTE_I .)
    EQUAL           reduce using rule 131 (var_cte -> CTE_I .)
    NEQ             reduce using rule 131 (var_cte -> CTE_I .)
    AND             reduce using rule 131 (var_cte -> CTE_I .)
    OR              reduce using rule 131 (var_cte -> CTE_I .)
    LB              reduce using rule 131 (var_cte -> CTE_I .)
    SEMICOL         reduce using rule 131 (var_cte -> CTE_I .)
    RP              reduce using rule 131 (var_cte -> CTE_I .)
    COMMA           reduce using rule 131 (var_cte -> CTE_I .)
    RC              reduce using rule 131 (var_cte -> CTE_I .)


state 207

    (132) var_cte -> CTE_F .

    MUL             reduce using rule 132 (var_cte -> CTE_F .)
    DIV             reduce using rule 132 (var_cte -> CTE_F .)
    PLUS            reduce using rule 132 (var_cte -> CTE_F .)
    MINUS           reduce using rule 132 (var_cte -> CTE_F .)
    GEQ             reduce using rule 132 (var_cte -> CTE_F .)
    LEQ             reduce using rule 132 (var_cte -> CTE_F .)
    GT              reduce using rule 132 (var_cte -> CTE_F .)
    LT              reduce using rule 132 (var_cte -> CTE_F .)
    EQUAL           reduce using rule 132 (var_cte -> CTE_F .)
    NEQ             reduce using rule 132 (var_cte -> CTE_F .)
    AND             reduce using rule 132 (var_cte -> CTE_F .)
    OR              reduce using rule 132 (var_cte -> CTE_F .)
    LB              reduce using rule 132 (var_cte -> CTE_F .)
    SEMICOL         reduce using rule 132 (var_cte -> CTE_F .)
    RP              reduce using rule 132 (var_cte -> CTE_F .)
    COMMA           reduce using rule 132 (var_cte -> CTE_F .)
    RC              reduce using rule 132 (var_cte -> CTE_F .)


state 208

    (133) var_cte -> CTE_B .

    MUL             reduce using rule 133 (var_cte -> CTE_B .)
    DIV             reduce using rule 133 (var_cte -> CTE_B .)
    PLUS            reduce using rule 133 (var_cte -> CTE_B .)
    MINUS           reduce using rule 133 (var_cte -> CTE_B .)
    GEQ             reduce using rule 133 (var_cte -> CTE_B .)
    LEQ             reduce using rule 133 (var_cte -> CTE_B .)
    GT              reduce using rule 133 (var_cte -> CTE_B .)
    LT              reduce using rule 133 (var_cte -> CTE_B .)
    EQUAL           reduce using rule 133 (var_cte -> CTE_B .)
    NEQ             reduce using rule 133 (var_cte -> CTE_B .)
    AND             reduce using rule 133 (var_cte -> CTE_B .)
    OR              reduce using rule 133 (var_cte -> CTE_B .)
    LB              reduce using rule 133 (var_cte -> CTE_B .)
    SEMICOL         reduce using rule 133 (var_cte -> CTE_B .)
    RP              reduce using rule 133 (var_cte -> CTE_B .)
    COMMA           reduce using rule 133 (var_cte -> CTE_B .)
    RC              reduce using rule 133 (var_cte -> CTE_B .)


state 209

    (91) loop -> WHILE expression block .

    PRINT           reduce using rule 91 (loop -> WHILE expression block .)
    INPUT           reduce using rule 91 (loop -> WHILE expression block .)
    IF              reduce using rule 91 (loop -> WHILE expression block .)
    WHILE           reduce using rule 91 (loop -> WHILE expression block .)
    RETURN          reduce using rule 91 (loop -> WHILE expression block .)
    ID              reduce using rule 91 (loop -> WHILE expression block .)
    RB              reduce using rule 91 (loop -> WHILE expression block .)


state 210

    (83) return -> RETURN expression SEMICOL .

    PRINT           reduce using rule 83 (return -> RETURN expression SEMICOL .)
    INPUT           reduce using rule 83 (return -> RETURN expression SEMICOL .)
    IF              reduce using rule 83 (return -> RETURN expression SEMICOL .)
    WHILE           reduce using rule 83 (return -> RETURN expression SEMICOL .)
    RETURN          reduce using rule 83 (return -> RETURN expression SEMICOL .)
    ID              reduce using rule 83 (return -> RETURN expression SEMICOL .)
    RB              reduce using rule 83 (return -> RETURN expression SEMICOL .)


state 211

    (84) obj -> ID array attribute .

    IS              reduce using rule 84 (obj -> ID array attribute .)
    LP              reduce using rule 84 (obj -> ID array attribute .)
    RP              reduce using rule 84 (obj -> ID array attribute .)
    MUL             reduce using rule 84 (obj -> ID array attribute .)
    DIV             reduce using rule 84 (obj -> ID array attribute .)
    PLUS            reduce using rule 84 (obj -> ID array attribute .)
    MINUS           reduce using rule 84 (obj -> ID array attribute .)
    GEQ             reduce using rule 84 (obj -> ID array attribute .)
    LEQ             reduce using rule 84 (obj -> ID array attribute .)
    GT              reduce using rule 84 (obj -> ID array attribute .)
    LT              reduce using rule 84 (obj -> ID array attribute .)
    EQUAL           reduce using rule 84 (obj -> ID array attribute .)
    NEQ             reduce using rule 84 (obj -> ID array attribute .)
    AND             reduce using rule 84 (obj -> ID array attribute .)
    OR              reduce using rule 84 (obj -> ID array attribute .)
    LB              reduce using rule 84 (obj -> ID array attribute .)
    SEMICOL         reduce using rule 84 (obj -> ID array attribute .)
    COMMA           reduce using rule 84 (obj -> ID array attribute .)
    RC              reduce using rule 84 (obj -> ID array attribute .)


state 212

    (138) attribute -> DOT . ID

    ID              shift and go to state 240


state 213

    (139) attribute -> empty .

    IS              reduce using rule 139 (attribute -> empty .)
    LP              reduce using rule 139 (attribute -> empty .)
    RP              reduce using rule 139 (attribute -> empty .)
    MUL             reduce using rule 139 (attribute -> empty .)
    DIV             reduce using rule 139 (attribute -> empty .)
    PLUS            reduce using rule 139 (attribute -> empty .)
    MINUS           reduce using rule 139 (attribute -> empty .)
    GEQ             reduce using rule 139 (attribute -> empty .)
    LEQ             reduce using rule 139 (attribute -> empty .)
    GT              reduce using rule 139 (attribute -> empty .)
    LT              reduce using rule 139 (attribute -> empty .)
    EQUAL           reduce using rule 139 (attribute -> empty .)
    NEQ             reduce using rule 139 (attribute -> empty .)
    AND             reduce using rule 139 (attribute -> empty .)
    OR              reduce using rule 139 (attribute -> empty .)
    LB              reduce using rule 139 (attribute -> empty .)
    SEMICOL         reduce using rule 139 (attribute -> empty .)
    COMMA           reduce using rule 139 (attribute -> empty .)
    RC              reduce using rule 139 (attribute -> empty .)


state 214

    (134) array -> LC expression . RC array_a

    RC              shift and go to state 241


state 215

    (17) typeM -> type0 LC CTE_I RC LC CTE_I . RC atomic type1

    RC              shift and go to state 242


state 216

    (18) typeM -> type0 LC CTE_I RC atomic type2 .

    SEMICOL         reduce using rule 18 (typeM -> type0 LC CTE_I RC atomic type2 .)


state 217

    (53) block -> LB block_a . RB

    RB              shift and go to state 243


state 218

    (86) print -> PRINT LP print_a RP . SEMICOL

    SEMICOL         shift and go to state 244


state 219

    (90) input -> INPUT LP obj RP . SEMICOL

    SEMICOL         shift and go to state 245


state 220

    (85) assignment -> obj IS expression SEMICOL .

    PRINT           reduce using rule 85 (assignment -> obj IS expression SEMICOL .)
    INPUT           reduce using rule 85 (assignment -> obj IS expression SEMICOL .)
    IF              reduce using rule 85 (assignment -> obj IS expression SEMICOL .)
    WHILE           reduce using rule 85 (assignment -> obj IS expression SEMICOL .)
    RETURN          reduce using rule 85 (assignment -> obj IS expression SEMICOL .)
    ID              reduce using rule 85 (assignment -> obj IS expression SEMICOL .)
    RB              reduce using rule 85 (assignment -> obj IS expression SEMICOL .)


state 221

    (140) call_func -> LP call_params RP .

    SEMICOL         reduce using rule 140 (call_func -> LP call_params RP .)
    MUL             reduce using rule 140 (call_func -> LP call_params RP .)
    DIV             reduce using rule 140 (call_func -> LP call_params RP .)
    PLUS            reduce using rule 140 (call_func -> LP call_params RP .)
    MINUS           reduce using rule 140 (call_func -> LP call_params RP .)
    GEQ             reduce using rule 140 (call_func -> LP call_params RP .)
    LEQ             reduce using rule 140 (call_func -> LP call_params RP .)
    GT              reduce using rule 140 (call_func -> LP call_params RP .)
    LT              reduce using rule 140 (call_func -> LP call_params RP .)
    EQUAL           reduce using rule 140 (call_func -> LP call_params RP .)
    NEQ             reduce using rule 140 (call_func -> LP call_params RP .)
    AND             reduce using rule 140 (call_func -> LP call_params RP .)
    OR              reduce using rule 140 (call_func -> LP call_params RP .)
    LB              reduce using rule 140 (call_func -> LP call_params RP .)
    RP              reduce using rule 140 (call_func -> LP call_params RP .)
    COMMA           reduce using rule 140 (call_func -> LP call_params RP .)
    RC              reduce using rule 140 (call_func -> LP call_params RP .)


state 222

    (93) call_params -> expression call_params_a .

    RP              reduce using rule 93 (call_params -> expression call_params_a .)


state 223

    (95) call_params_a -> COMMA . expression call_params_a
    (104) expression -> . comparison expression_a
    (108) comparison -> . exp comparison_a
    (117) exp -> . term exp_a
    (121) term -> . factor term_a
    (125) factor -> . LP expression RP
    (126) factor -> . factor_a var_cte
    (127) factor_a -> . MINUS
    (128) factor_a -> . NOT
    (129) factor_a -> . empty
    (143) empty -> .

    LP              shift and go to state 154
    MINUS           shift and go to state 156
    NOT             shift and go to state 157
    CTE_I           reduce using rule 143 (empty -> .)
    CTE_F           reduce using rule 143 (empty -> .)
    CTE_B           reduce using rule 143 (empty -> .)
    ID              reduce using rule 143 (empty -> .)

    expression                     shift and go to state 246
    comparison                     shift and go to state 150
    exp                            shift and go to state 151
    term                           shift and go to state 152
    factor                         shift and go to state 153
    factor_a                       shift and go to state 155
    empty                          shift and go to state 158

state 224

    (96) call_params_a -> empty .

    RP              reduce using rule 96 (call_params_a -> empty .)


state 225

    (97) condition -> IF expression block condition_a . condition_b
    (100) condition_b -> . else
    (101) condition_b -> . empty
    (103) else -> . ELSE block
    (143) empty -> .

    ELSE            shift and go to state 250
    PRINT           reduce using rule 143 (empty -> .)
    INPUT           reduce using rule 143 (empty -> .)
    IF              reduce using rule 143 (empty -> .)
    WHILE           reduce using rule 143 (empty -> .)
    RETURN          reduce using rule 143 (empty -> .)
    ID              reduce using rule 143 (empty -> .)
    RB              reduce using rule 143 (empty -> .)

    condition_b                    shift and go to state 247
    else                           shift and go to state 248
    empty                          shift and go to state 249

state 226

    (98) condition_a -> elseif . condition_a
    (98) condition_a -> . elseif condition_a
    (99) condition_a -> . empty
    (102) elseif -> . ELSEIF expression block
    (143) empty -> .

    ELSEIF          shift and go to state 228
    ELSE            reduce using rule 143 (empty -> .)
    PRINT           reduce using rule 143 (empty -> .)
    INPUT           reduce using rule 143 (empty -> .)
    IF              reduce using rule 143 (empty -> .)
    WHILE           reduce using rule 143 (empty -> .)
    RETURN          reduce using rule 143 (empty -> .)
    ID              reduce using rule 143 (empty -> .)
    RB              reduce using rule 143 (empty -> .)

    elseif                         shift and go to state 226
    condition_a                    shift and go to state 251
    empty                          shift and go to state 227

state 227

    (99) condition_a -> empty .

    ELSE            reduce using rule 99 (condition_a -> empty .)
    PRINT           reduce using rule 99 (condition_a -> empty .)
    INPUT           reduce using rule 99 (condition_a -> empty .)
    IF              reduce using rule 99 (condition_a -> empty .)
    WHILE           reduce using rule 99 (condition_a -> empty .)
    RETURN          reduce using rule 99 (condition_a -> empty .)
    ID              reduce using rule 99 (condition_a -> empty .)
    RB              reduce using rule 99 (condition_a -> empty .)


state 228

    (102) elseif -> ELSEIF . expression block
    (104) expression -> . comparison expression_a
    (108) comparison -> . exp comparison_a
    (117) exp -> . term exp_a
    (121) term -> . factor term_a
    (125) factor -> . LP expression RP
    (126) factor -> . factor_a var_cte
    (127) factor_a -> . MINUS
    (128) factor_a -> . NOT
    (129) factor_a -> . empty
    (143) empty -> .

    LP              shift and go to state 154
    MINUS           shift and go to state 156
    NOT             shift and go to state 157
    CTE_I           reduce using rule 143 (empty -> .)
    CTE_F           reduce using rule 143 (empty -> .)
    CTE_B           reduce using rule 143 (empty -> .)
    ID              reduce using rule 143 (empty -> .)

    expression                     shift and go to state 252
    comparison                     shift and go to state 150
    exp                            shift and go to state 151
    term                           shift and go to state 152
    factor                         shift and go to state 153
    factor_a                       shift and go to state 155
    empty                          shift and go to state 158

state 229

    (105) expression_a -> AND comparison . expression_a
    (105) expression_a -> . AND comparison expression_a
    (106) expression_a -> . OR comparison
    (107) expression_a -> . empty
    (143) empty -> .

    AND             shift and go to state 183
    OR              shift and go to state 184
    LB              reduce using rule 143 (empty -> .)
    SEMICOL         reduce using rule 143 (empty -> .)
    RP              reduce using rule 143 (empty -> .)
    COMMA           reduce using rule 143 (empty -> .)
    RC              reduce using rule 143 (empty -> .)

    expression_a                   shift and go to state 253
    empty                          shift and go to state 185

state 230

    (106) expression_a -> OR comparison .

    LB              reduce using rule 106 (expression_a -> OR comparison .)
    SEMICOL         reduce using rule 106 (expression_a -> OR comparison .)
    RP              reduce using rule 106 (expression_a -> OR comparison .)
    COMMA           reduce using rule 106 (expression_a -> OR comparison .)
    RC              reduce using rule 106 (expression_a -> OR comparison .)


state 231

    (109) comparison_a -> comparison_b exp . comparison_a
    (109) comparison_a -> . comparison_b exp comparison_a
    (110) comparison_a -> . empty
    (111) comparison_b -> . GEQ
    (112) comparison_b -> . LEQ
    (113) comparison_b -> . GT
    (114) comparison_b -> . LT
    (115) comparison_b -> . EQUAL
    (116) comparison_b -> . NEQ
    (143) empty -> .

    GEQ             shift and go to state 189
    LEQ             shift and go to state 190
    GT              shift and go to state 191
    LT              shift and go to state 192
    EQUAL           shift and go to state 193
    NEQ             shift and go to state 194
    AND             reduce using rule 143 (empty -> .)
    OR              reduce using rule 143 (empty -> .)
    LB              reduce using rule 143 (empty -> .)
    SEMICOL         reduce using rule 143 (empty -> .)
    RP              reduce using rule 143 (empty -> .)
    COMMA           reduce using rule 143 (empty -> .)
    RC              reduce using rule 143 (empty -> .)

    comparison_b                   shift and go to state 187
    comparison_a                   shift and go to state 254
    empty                          shift and go to state 188

state 232

    (118) exp_a -> PLUS term . exp_a
    (118) exp_a -> . PLUS term exp_a
    (119) exp_a -> . MINUS term exp_a
    (120) exp_a -> . empty
    (143) empty -> .

    PLUS            shift and go to state 196
    MINUS           shift and go to state 197
    GEQ             reduce using rule 143 (empty -> .)
    LEQ             reduce using rule 143 (empty -> .)
    GT              reduce using rule 143 (empty -> .)
    LT              reduce using rule 143 (empty -> .)
    EQUAL           reduce using rule 143 (empty -> .)
    NEQ             reduce using rule 143 (empty -> .)
    AND             reduce using rule 143 (empty -> .)
    OR              reduce using rule 143 (empty -> .)
    LB              reduce using rule 143 (empty -> .)
    SEMICOL         reduce using rule 143 (empty -> .)
    RP              reduce using rule 143 (empty -> .)
    COMMA           reduce using rule 143 (empty -> .)
    RC              reduce using rule 143 (empty -> .)

    exp_a                          shift and go to state 255
    empty                          shift and go to state 198

state 233

    (119) exp_a -> MINUS term . exp_a
    (118) exp_a -> . PLUS term exp_a
    (119) exp_a -> . MINUS term exp_a
    (120) exp_a -> . empty
    (143) empty -> .

    PLUS            shift and go to state 196
    MINUS           shift and go to state 197
    GEQ             reduce using rule 143 (empty -> .)
    LEQ             reduce using rule 143 (empty -> .)
    GT              reduce using rule 143 (empty -> .)
    LT              reduce using rule 143 (empty -> .)
    EQUAL           reduce using rule 143 (empty -> .)
    NEQ             reduce using rule 143 (empty -> .)
    AND             reduce using rule 143 (empty -> .)
    OR              reduce using rule 143 (empty -> .)
    LB              reduce using rule 143 (empty -> .)
    SEMICOL         reduce using rule 143 (empty -> .)
    RP              reduce using rule 143 (empty -> .)
    COMMA           reduce using rule 143 (empty -> .)
    RC              reduce using rule 143 (empty -> .)

    exp_a                          shift and go to state 256
    empty                          shift and go to state 198

state 234

    (122) term_a -> MUL factor . term_a
    (122) term_a -> . MUL factor term_a
    (123) term_a -> . DIV factor term_a
    (124) term_a -> . empty
    (143) empty -> .

    MUL             shift and go to state 200
    DIV             shift and go to state 201
    PLUS            reduce using rule 143 (empty -> .)
    MINUS           reduce using rule 143 (empty -> .)
    GEQ             reduce using rule 143 (empty -> .)
    LEQ             reduce using rule 143 (empty -> .)
    GT              reduce using rule 143 (empty -> .)
    LT              reduce using rule 143 (empty -> .)
    EQUAL           reduce using rule 143 (empty -> .)
    NEQ             reduce using rule 143 (empty -> .)
    AND             reduce using rule 143 (empty -> .)
    OR              reduce using rule 143 (empty -> .)
    LB              reduce using rule 143 (empty -> .)
    SEMICOL         reduce using rule 143 (empty -> .)
    RP              reduce using rule 143 (empty -> .)
    COMMA           reduce using rule 143 (empty -> .)
    RC              reduce using rule 143 (empty -> .)

    term_a                         shift and go to state 257
    empty                          shift and go to state 202

state 235

    (123) term_a -> DIV factor . term_a
    (122) term_a -> . MUL factor term_a
    (123) term_a -> . DIV factor term_a
    (124) term_a -> . empty
    (143) empty -> .

    MUL             shift and go to state 200
    DIV             shift and go to state 201
    PLUS            reduce using rule 143 (empty -> .)
    MINUS           reduce using rule 143 (empty -> .)
    GEQ             reduce using rule 143 (empty -> .)
    LEQ             reduce using rule 143 (empty -> .)
    GT              reduce using rule 143 (empty -> .)
    LT              reduce using rule 143 (empty -> .)
    EQUAL           reduce using rule 143 (empty -> .)
    NEQ             reduce using rule 143 (empty -> .)
    AND             reduce using rule 143 (empty -> .)
    OR              reduce using rule 143 (empty -> .)
    LB              reduce using rule 143 (empty -> .)
    SEMICOL         reduce using rule 143 (empty -> .)
    RP              reduce using rule 143 (empty -> .)
    COMMA           reduce using rule 143 (empty -> .)
    RC              reduce using rule 143 (empty -> .)

    term_a                         shift and go to state 258
    empty                          shift and go to state 202

state 236

    (125) factor -> LP expression RP .

    MUL             reduce using rule 125 (factor -> LP expression RP .)
    DIV             reduce using rule 125 (factor -> LP expression RP .)
    PLUS            reduce using rule 125 (factor -> LP expression RP .)
    MINUS           reduce using rule 125 (factor -> LP expression RP .)
    GEQ             reduce using rule 125 (factor -> LP expression RP .)
    LEQ             reduce using rule 125 (factor -> LP expression RP .)
    GT              reduce using rule 125 (factor -> LP expression RP .)
    LT              reduce using rule 125 (factor -> LP expression RP .)
    EQUAL           reduce using rule 125 (factor -> LP expression RP .)
    NEQ             reduce using rule 125 (factor -> LP expression RP .)
    AND             reduce using rule 125 (factor -> LP expression RP .)
    OR              reduce using rule 125 (factor -> LP expression RP .)
    LB              reduce using rule 125 (factor -> LP expression RP .)
    SEMICOL         reduce using rule 125 (factor -> LP expression RP .)
    RP              reduce using rule 125 (factor -> LP expression RP .)
    COMMA           reduce using rule 125 (factor -> LP expression RP .)
    RC              reduce using rule 125 (factor -> LP expression RP .)


state 237

    (130) var_cte -> obj call_func_optional .

    MUL             reduce using rule 130 (var_cte -> obj call_func_optional .)
    DIV             reduce using rule 130 (var_cte -> obj call_func_optional .)
    PLUS            reduce using rule 130 (var_cte -> obj call_func_optional .)
    MINUS           reduce using rule 130 (var_cte -> obj call_func_optional .)
    GEQ             reduce using rule 130 (var_cte -> obj call_func_optional .)
    LEQ             reduce using rule 130 (var_cte -> obj call_func_optional .)
    GT              reduce using rule 130 (var_cte -> obj call_func_optional .)
    LT              reduce using rule 130 (var_cte -> obj call_func_optional .)
    EQUAL           reduce using rule 130 (var_cte -> obj call_func_optional .)
    NEQ             reduce using rule 130 (var_cte -> obj call_func_optional .)
    AND             reduce using rule 130 (var_cte -> obj call_func_optional .)
    OR              reduce using rule 130 (var_cte -> obj call_func_optional .)
    LB              reduce using rule 130 (var_cte -> obj call_func_optional .)
    SEMICOL         reduce using rule 130 (var_cte -> obj call_func_optional .)
    RP              reduce using rule 130 (var_cte -> obj call_func_optional .)
    COMMA           reduce using rule 130 (var_cte -> obj call_func_optional .)
    RC              reduce using rule 130 (var_cte -> obj call_func_optional .)


state 238

    (141) call_func_optional -> call_func .

    MUL             reduce using rule 141 (call_func_optional -> call_func .)
    DIV             reduce using rule 141 (call_func_optional -> call_func .)
    PLUS            reduce using rule 141 (call_func_optional -> call_func .)
    MINUS           reduce using rule 141 (call_func_optional -> call_func .)
    GEQ             reduce using rule 141 (call_func_optional -> call_func .)
    LEQ             reduce using rule 141 (call_func_optional -> call_func .)
    GT              reduce using rule 141 (call_func_optional -> call_func .)
    LT              reduce using rule 141 (call_func_optional -> call_func .)
    EQUAL           reduce using rule 141 (call_func_optional -> call_func .)
    NEQ             reduce using rule 141 (call_func_optional -> call_func .)
    AND             reduce using rule 141 (call_func_optional -> call_func .)
    OR              reduce using rule 141 (call_func_optional -> call_func .)
    LB              reduce using rule 141 (call_func_optional -> call_func .)
    SEMICOL         reduce using rule 141 (call_func_optional -> call_func .)
    RP              reduce using rule 141 (call_func_optional -> call_func .)
    COMMA           reduce using rule 141 (call_func_optional -> call_func .)
    RC              reduce using rule 141 (call_func_optional -> call_func .)


state 239

    (142) call_func_optional -> empty .

    MUL             reduce using rule 142 (call_func_optional -> empty .)
    DIV             reduce using rule 142 (call_func_optional -> empty .)
    PLUS            reduce using rule 142 (call_func_optional -> empty .)
    MINUS           reduce using rule 142 (call_func_optional -> empty .)
    GEQ             reduce using rule 142 (call_func_optional -> empty .)
    LEQ             reduce using rule 142 (call_func_optional -> empty .)
    GT              reduce using rule 142 (call_func_optional -> empty .)
    LT              reduce using rule 142 (call_func_optional -> empty .)
    EQUAL           reduce using rule 142 (call_func_optional -> empty .)
    NEQ             reduce using rule 142 (call_func_optional -> empty .)
    AND             reduce using rule 142 (call_func_optional -> empty .)
    OR              reduce using rule 142 (call_func_optional -> empty .)
    LB              reduce using rule 142 (call_func_optional -> empty .)
    SEMICOL         reduce using rule 142 (call_func_optional -> empty .)
    RP              reduce using rule 142 (call_func_optional -> empty .)
    COMMA           reduce using rule 142 (call_func_optional -> empty .)
    RC              reduce using rule 142 (call_func_optional -> empty .)


state 240

    (138) attribute -> DOT ID .

    IS              reduce using rule 138 (attribute -> DOT ID .)
    LP              reduce using rule 138 (attribute -> DOT ID .)
    RP              reduce using rule 138 (attribute -> DOT ID .)
    MUL             reduce using rule 138 (attribute -> DOT ID .)
    DIV             reduce using rule 138 (attribute -> DOT ID .)
    PLUS            reduce using rule 138 (attribute -> DOT ID .)
    MINUS           reduce using rule 138 (attribute -> DOT ID .)
    GEQ             reduce using rule 138 (attribute -> DOT ID .)
    LEQ             reduce using rule 138 (attribute -> DOT ID .)
    GT              reduce using rule 138 (attribute -> DOT ID .)
    LT              reduce using rule 138 (attribute -> DOT ID .)
    EQUAL           reduce using rule 138 (attribute -> DOT ID .)
    NEQ             reduce using rule 138 (attribute -> DOT ID .)
    AND             reduce using rule 138 (attribute -> DOT ID .)
    OR              reduce using rule 138 (attribute -> DOT ID .)
    LB              reduce using rule 138 (attribute -> DOT ID .)
    SEMICOL         reduce using rule 138 (attribute -> DOT ID .)
    COMMA           reduce using rule 138 (attribute -> DOT ID .)
    RC              reduce using rule 138 (attribute -> DOT ID .)


state 241

    (134) array -> LC expression RC . array_a
    (136) array_a -> . LC expression RC
    (137) array_a -> . empty
    (143) empty -> .

    LC              shift and go to state 259
    DOT             reduce using rule 143 (empty -> .)
    IS              reduce using rule 143 (empty -> .)
    LP              reduce using rule 143 (empty -> .)
    RP              reduce using rule 143 (empty -> .)
    MUL             reduce using rule 143 (empty -> .)
    DIV             reduce using rule 143 (empty -> .)
    PLUS            reduce using rule 143 (empty -> .)
    MINUS           reduce using rule 143 (empty -> .)
    GEQ             reduce using rule 143 (empty -> .)
    LEQ             reduce using rule 143 (empty -> .)
    GT              reduce using rule 143 (empty -> .)
    LT              reduce using rule 143 (empty -> .)
    EQUAL           reduce using rule 143 (empty -> .)
    NEQ             reduce using rule 143 (empty -> .)
    AND             reduce using rule 143 (empty -> .)
    OR              reduce using rule 143 (empty -> .)
    LB              reduce using rule 143 (empty -> .)
    SEMICOL         reduce using rule 143 (empty -> .)
    COMMA           reduce using rule 143 (empty -> .)
    RC              reduce using rule 143 (empty -> .)

    array_a                        shift and go to state 260
    empty                          shift and go to state 261

state 242

    (17) typeM -> type0 LC CTE_I RC LC CTE_I RC . atomic type1
    (25) atomic -> . INT type3
    (26) atomic -> . FLOAT type3
    (27) atomic -> . BOOL type3

    INT             shift and go to state 48
    FLOAT           shift and go to state 49
    BOOL            shift and go to state 50

    atomic                         shift and go to state 262

state 243

    (53) block -> LB block_a RB .

    INIT            reduce using rule 53 (block -> LB block_a RB .)
    PRIVATE         reduce using rule 53 (block -> LB block_a RB .)
    RB              reduce using rule 53 (block -> LB block_a RB .)
    FUNCTION        reduce using rule 53 (block -> LB block_a RB .)
    ELSEIF          reduce using rule 53 (block -> LB block_a RB .)
    ELSE            reduce using rule 53 (block -> LB block_a RB .)
    PRINT           reduce using rule 53 (block -> LB block_a RB .)
    INPUT           reduce using rule 53 (block -> LB block_a RB .)
    IF              reduce using rule 53 (block -> LB block_a RB .)
    WHILE           reduce using rule 53 (block -> LB block_a RB .)
    RETURN          reduce using rule 53 (block -> LB block_a RB .)
    ID              reduce using rule 53 (block -> LB block_a RB .)


state 244

    (86) print -> PRINT LP print_a RP SEMICOL .

    PRINT           reduce using rule 86 (print -> PRINT LP print_a RP SEMICOL .)
    INPUT           reduce using rule 86 (print -> PRINT LP print_a RP SEMICOL .)
    IF              reduce using rule 86 (print -> PRINT LP print_a RP SEMICOL .)
    WHILE           reduce using rule 86 (print -> PRINT LP print_a RP SEMICOL .)
    RETURN          reduce using rule 86 (print -> PRINT LP print_a RP SEMICOL .)
    ID              reduce using rule 86 (print -> PRINT LP print_a RP SEMICOL .)
    RB              reduce using rule 86 (print -> PRINT LP print_a RP SEMICOL .)


state 245

    (90) input -> INPUT LP obj RP SEMICOL .

    PRINT           reduce using rule 90 (input -> INPUT LP obj RP SEMICOL .)
    INPUT           reduce using rule 90 (input -> INPUT LP obj RP SEMICOL .)
    IF              reduce using rule 90 (input -> INPUT LP obj RP SEMICOL .)
    WHILE           reduce using rule 90 (input -> INPUT LP obj RP SEMICOL .)
    RETURN          reduce using rule 90 (input -> INPUT LP obj RP SEMICOL .)
    ID              reduce using rule 90 (input -> INPUT LP obj RP SEMICOL .)
    RB              reduce using rule 90 (input -> INPUT LP obj RP SEMICOL .)


state 246

    (95) call_params_a -> COMMA expression . call_params_a
    (95) call_params_a -> . COMMA expression call_params_a
    (96) call_params_a -> . empty
    (143) empty -> .

    COMMA           shift and go to state 223
    RP              reduce using rule 143 (empty -> .)

    call_params_a                  shift and go to state 263
    empty                          shift and go to state 224

state 247

    (97) condition -> IF expression block condition_a condition_b .

    PRINT           reduce using rule 97 (condition -> IF expression block condition_a condition_b .)
    INPUT           reduce using rule 97 (condition -> IF expression block condition_a condition_b .)
    IF              reduce using rule 97 (condition -> IF expression block condition_a condition_b .)
    WHILE           reduce using rule 97 (condition -> IF expression block condition_a condition_b .)
    RETURN          reduce using rule 97 (condition -> IF expression block condition_a condition_b .)
    ID              reduce using rule 97 (condition -> IF expression block condition_a condition_b .)
    RB              reduce using rule 97 (condition -> IF expression block condition_a condition_b .)


state 248

    (100) condition_b -> else .

    PRINT           reduce using rule 100 (condition_b -> else .)
    INPUT           reduce using rule 100 (condition_b -> else .)
    IF              reduce using rule 100 (condition_b -> else .)
    WHILE           reduce using rule 100 (condition_b -> else .)
    RETURN          reduce using rule 100 (condition_b -> else .)
    ID              reduce using rule 100 (condition_b -> else .)
    RB              reduce using rule 100 (condition_b -> else .)


state 249

    (101) condition_b -> empty .

    PRINT           reduce using rule 101 (condition_b -> empty .)
    INPUT           reduce using rule 101 (condition_b -> empty .)
    IF              reduce using rule 101 (condition_b -> empty .)
    WHILE           reduce using rule 101 (condition_b -> empty .)
    RETURN          reduce using rule 101 (condition_b -> empty .)
    ID              reduce using rule 101 (condition_b -> empty .)
    RB              reduce using rule 101 (condition_b -> empty .)


state 250

    (103) else -> ELSE . block
    (53) block -> . LB block_a RB

    LB              shift and go to state 170

    block                          shift and go to state 264

state 251

    (98) condition_a -> elseif condition_a .

    ELSE            reduce using rule 98 (condition_a -> elseif condition_a .)
    PRINT           reduce using rule 98 (condition_a -> elseif condition_a .)
    INPUT           reduce using rule 98 (condition_a -> elseif condition_a .)
    IF              reduce using rule 98 (condition_a -> elseif condition_a .)
    WHILE           reduce using rule 98 (condition_a -> elseif condition_a .)
    RETURN          reduce using rule 98 (condition_a -> elseif condition_a .)
    ID              reduce using rule 98 (condition_a -> elseif condition_a .)
    RB              reduce using rule 98 (condition_a -> elseif condition_a .)


state 252

    (102) elseif -> ELSEIF expression . block
    (53) block -> . LB block_a RB

    LB              shift and go to state 170

    block                          shift and go to state 265

state 253

    (105) expression_a -> AND comparison expression_a .

    LB              reduce using rule 105 (expression_a -> AND comparison expression_a .)
    SEMICOL         reduce using rule 105 (expression_a -> AND comparison expression_a .)
    RP              reduce using rule 105 (expression_a -> AND comparison expression_a .)
    COMMA           reduce using rule 105 (expression_a -> AND comparison expression_a .)
    RC              reduce using rule 105 (expression_a -> AND comparison expression_a .)


state 254

    (109) comparison_a -> comparison_b exp comparison_a .

    AND             reduce using rule 109 (comparison_a -> comparison_b exp comparison_a .)
    OR              reduce using rule 109 (comparison_a -> comparison_b exp comparison_a .)
    LB              reduce using rule 109 (comparison_a -> comparison_b exp comparison_a .)
    SEMICOL         reduce using rule 109 (comparison_a -> comparison_b exp comparison_a .)
    RP              reduce using rule 109 (comparison_a -> comparison_b exp comparison_a .)
    COMMA           reduce using rule 109 (comparison_a -> comparison_b exp comparison_a .)
    RC              reduce using rule 109 (comparison_a -> comparison_b exp comparison_a .)


state 255

    (118) exp_a -> PLUS term exp_a .

    GEQ             reduce using rule 118 (exp_a -> PLUS term exp_a .)
    LEQ             reduce using rule 118 (exp_a -> PLUS term exp_a .)
    GT              reduce using rule 118 (exp_a -> PLUS term exp_a .)
    LT              reduce using rule 118 (exp_a -> PLUS term exp_a .)
    EQUAL           reduce using rule 118 (exp_a -> PLUS term exp_a .)
    NEQ             reduce using rule 118 (exp_a -> PLUS term exp_a .)
    AND             reduce using rule 118 (exp_a -> PLUS term exp_a .)
    OR              reduce using rule 118 (exp_a -> PLUS term exp_a .)
    LB              reduce using rule 118 (exp_a -> PLUS term exp_a .)
    SEMICOL         reduce using rule 118 (exp_a -> PLUS term exp_a .)
    RP              reduce using rule 118 (exp_a -> PLUS term exp_a .)
    COMMA           reduce using rule 118 (exp_a -> PLUS term exp_a .)
    RC              reduce using rule 118 (exp_a -> PLUS term exp_a .)


state 256

    (119) exp_a -> MINUS term exp_a .

    GEQ             reduce using rule 119 (exp_a -> MINUS term exp_a .)
    LEQ             reduce using rule 119 (exp_a -> MINUS term exp_a .)
    GT              reduce using rule 119 (exp_a -> MINUS term exp_a .)
    LT              reduce using rule 119 (exp_a -> MINUS term exp_a .)
    EQUAL           reduce using rule 119 (exp_a -> MINUS term exp_a .)
    NEQ             reduce using rule 119 (exp_a -> MINUS term exp_a .)
    AND             reduce using rule 119 (exp_a -> MINUS term exp_a .)
    OR              reduce using rule 119 (exp_a -> MINUS term exp_a .)
    LB              reduce using rule 119 (exp_a -> MINUS term exp_a .)
    SEMICOL         reduce using rule 119 (exp_a -> MINUS term exp_a .)
    RP              reduce using rule 119 (exp_a -> MINUS term exp_a .)
    COMMA           reduce using rule 119 (exp_a -> MINUS term exp_a .)
    RC              reduce using rule 119 (exp_a -> MINUS term exp_a .)


state 257

    (122) term_a -> MUL factor term_a .

    PLUS            reduce using rule 122 (term_a -> MUL factor term_a .)
    MINUS           reduce using rule 122 (term_a -> MUL factor term_a .)
    GEQ             reduce using rule 122 (term_a -> MUL factor term_a .)
    LEQ             reduce using rule 122 (term_a -> MUL factor term_a .)
    GT              reduce using rule 122 (term_a -> MUL factor term_a .)
    LT              reduce using rule 122 (term_a -> MUL factor term_a .)
    EQUAL           reduce using rule 122 (term_a -> MUL factor term_a .)
    NEQ             reduce using rule 122 (term_a -> MUL factor term_a .)
    AND             reduce using rule 122 (term_a -> MUL factor term_a .)
    OR              reduce using rule 122 (term_a -> MUL factor term_a .)
    LB              reduce using rule 122 (term_a -> MUL factor term_a .)
    SEMICOL         reduce using rule 122 (term_a -> MUL factor term_a .)
    RP              reduce using rule 122 (term_a -> MUL factor term_a .)
    COMMA           reduce using rule 122 (term_a -> MUL factor term_a .)
    RC              reduce using rule 122 (term_a -> MUL factor term_a .)


state 258

    (123) term_a -> DIV factor term_a .

    PLUS            reduce using rule 123 (term_a -> DIV factor term_a .)
    MINUS           reduce using rule 123 (term_a -> DIV factor term_a .)
    GEQ             reduce using rule 123 (term_a -> DIV factor term_a .)
    LEQ             reduce using rule 123 (term_a -> DIV factor term_a .)
    GT              reduce using rule 123 (term_a -> DIV factor term_a .)
    LT              reduce using rule 123 (term_a -> DIV factor term_a .)
    EQUAL           reduce using rule 123 (term_a -> DIV factor term_a .)
    NEQ             reduce using rule 123 (term_a -> DIV factor term_a .)
    AND             reduce using rule 123 (term_a -> DIV factor term_a .)
    OR              reduce using rule 123 (term_a -> DIV factor term_a .)
    LB              reduce using rule 123 (term_a -> DIV factor term_a .)
    SEMICOL         reduce using rule 123 (term_a -> DIV factor term_a .)
    RP              reduce using rule 123 (term_a -> DIV factor term_a .)
    COMMA           reduce using rule 123 (term_a -> DIV factor term_a .)
    RC              reduce using rule 123 (term_a -> DIV factor term_a .)


state 259

    (136) array_a -> LC . expression RC
    (104) expression -> . comparison expression_a
    (108) comparison -> . exp comparison_a
    (117) exp -> . term exp_a
    (121) term -> . factor term_a
    (125) factor -> . LP expression RP
    (126) factor -> . factor_a var_cte
    (127) factor_a -> . MINUS
    (128) factor_a -> . NOT
    (129) factor_a -> . empty
    (143) empty -> .

    LP              shift and go to state 154
    MINUS           shift and go to state 156
    NOT             shift and go to state 157
    CTE_I           reduce using rule 143 (empty -> .)
    CTE_F           reduce using rule 143 (empty -> .)
    CTE_B           reduce using rule 143 (empty -> .)
    ID              reduce using rule 143 (empty -> .)

    expression                     shift and go to state 266
    comparison                     shift and go to state 150
    exp                            shift and go to state 151
    term                           shift and go to state 152
    factor                         shift and go to state 153
    factor_a                       shift and go to state 155
    empty                          shift and go to state 158

state 260

    (134) array -> LC expression RC array_a .

    DOT             reduce using rule 134 (array -> LC expression RC array_a .)
    IS              reduce using rule 134 (array -> LC expression RC array_a .)
    LP              reduce using rule 134 (array -> LC expression RC array_a .)
    RP              reduce using rule 134 (array -> LC expression RC array_a .)
    MUL             reduce using rule 134 (array -> LC expression RC array_a .)
    DIV             reduce using rule 134 (array -> LC expression RC array_a .)
    PLUS            reduce using rule 134 (array -> LC expression RC array_a .)
    MINUS           reduce using rule 134 (array -> LC expression RC array_a .)
    GEQ             reduce using rule 134 (array -> LC expression RC array_a .)
    LEQ             reduce using rule 134 (array -> LC expression RC array_a .)
    GT              reduce using rule 134 (array -> LC expression RC array_a .)
    LT              reduce using rule 134 (array -> LC expression RC array_a .)
    EQUAL           reduce using rule 134 (array -> LC expression RC array_a .)
    NEQ             reduce using rule 134 (array -> LC expression RC array_a .)
    AND             reduce using rule 134 (array -> LC expression RC array_a .)
    OR              reduce using rule 134 (array -> LC expression RC array_a .)
    LB              reduce using rule 134 (array -> LC expression RC array_a .)
    SEMICOL         reduce using rule 134 (array -> LC expression RC array_a .)
    COMMA           reduce using rule 134 (array -> LC expression RC array_a .)
    RC              reduce using rule 134 (array -> LC expression RC array_a .)


state 261

    (137) array_a -> empty .

    DOT             reduce using rule 137 (array_a -> empty .)
    IS              reduce using rule 137 (array_a -> empty .)
    LP              reduce using rule 137 (array_a -> empty .)
    RP              reduce using rule 137 (array_a -> empty .)
    MUL             reduce using rule 137 (array_a -> empty .)
    DIV             reduce using rule 137 (array_a -> empty .)
    PLUS            reduce using rule 137 (array_a -> empty .)
    MINUS           reduce using rule 137 (array_a -> empty .)
    GEQ             reduce using rule 137 (array_a -> empty .)
    LEQ             reduce using rule 137 (array_a -> empty .)
    GT              reduce using rule 137 (array_a -> empty .)
    LT              reduce using rule 137 (array_a -> empty .)
    EQUAL           reduce using rule 137 (array_a -> empty .)
    NEQ             reduce using rule 137 (array_a -> empty .)
    AND             reduce using rule 137 (array_a -> empty .)
    OR              reduce using rule 137 (array_a -> empty .)
    LB              reduce using rule 137 (array_a -> empty .)
    SEMICOL         reduce using rule 137 (array_a -> empty .)
    COMMA           reduce using rule 137 (array_a -> empty .)
    RC              reduce using rule 137 (array_a -> empty .)


state 262

    (17) typeM -> type0 LC CTE_I RC LC CTE_I RC atomic . type1
    (21) type1 -> .

    SEMICOL         reduce using rule 21 (type1 -> .)

    type1                          shift and go to state 267

state 263

    (95) call_params_a -> COMMA expression call_params_a .

    RP              reduce using rule 95 (call_params_a -> COMMA expression call_params_a .)


state 264

    (103) else -> ELSE block .

    PRINT           reduce using rule 103 (else -> ELSE block .)
    INPUT           reduce using rule 103 (else -> ELSE block .)
    IF              reduce using rule 103 (else -> ELSE block .)
    WHILE           reduce using rule 103 (else -> ELSE block .)
    RETURN          reduce using rule 103 (else -> ELSE block .)
    ID              reduce using rule 103 (else -> ELSE block .)
    RB              reduce using rule 103 (else -> ELSE block .)


state 265

    (102) elseif -> ELSEIF expression block .

    ELSEIF          reduce using rule 102 (elseif -> ELSEIF expression block .)
    ELSE            reduce using rule 102 (elseif -> ELSEIF expression block .)
    PRINT           reduce using rule 102 (elseif -> ELSEIF expression block .)
    INPUT           reduce using rule 102 (elseif -> ELSEIF expression block .)
    IF              reduce using rule 102 (elseif -> ELSEIF expression block .)
    WHILE           reduce using rule 102 (elseif -> ELSEIF expression block .)
    RETURN          reduce using rule 102 (elseif -> ELSEIF expression block .)
    ID              reduce using rule 102 (elseif -> ELSEIF expression block .)
    RB              reduce using rule 102 (elseif -> ELSEIF expression block .)


state 266

    (136) array_a -> LC expression . RC

    RC              shift and go to state 268


state 267

    (17) typeM -> type0 LC CTE_I RC LC CTE_I RC atomic type1 .

    SEMICOL         reduce using rule 17 (typeM -> type0 LC CTE_I RC LC CTE_I RC atomic type1 .)


state 268

    (136) array_a -> LC expression RC .

    DOT             reduce using rule 136 (array_a -> LC expression RC .)
    IS              reduce using rule 136 (array_a -> LC expression RC .)
    LP              reduce using rule 136 (array_a -> LC expression RC .)
    RP              reduce using rule 136 (array_a -> LC expression RC .)
    MUL             reduce using rule 136 (array_a -> LC expression RC .)
    DIV             reduce using rule 136 (array_a -> LC expression RC .)
    PLUS            reduce using rule 136 (array_a -> LC expression RC .)
    MINUS           reduce using rule 136 (array_a -> LC expression RC .)
    GEQ             reduce using rule 136 (array_a -> LC expression RC .)
    LEQ             reduce using rule 136 (array_a -> LC expression RC .)
    GT              reduce using rule 136 (array_a -> LC expression RC .)
    LT              reduce using rule 136 (array_a -> LC expression RC .)
    EQUAL           reduce using rule 136 (array_a -> LC expression RC .)
    NEQ             reduce using rule 136 (array_a -> LC expression RC .)
    AND             reduce using rule 136 (array_a -> LC expression RC .)
    OR              reduce using rule 136 (array_a -> LC expression RC .)
    LB              reduce using rule 136 (array_a -> LC expression RC .)
    SEMICOL         reduce using rule 136 (array_a -> LC expression RC .)
    COMMA           reduce using rule 136 (array_a -> LC expression RC .)
    RC              reduce using rule 136 (array_a -> LC expression RC .)

