Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> program_a program_c program_d main
Rule 2     program_a -> program_b program_a
Rule 3     program_a -> empty
Rule 4     program_b -> let prog1
Rule 5     program_b -> class prog2
Rule 6     program_c -> var prog3 program_c
Rule 7     program_c -> empty
Rule 8     program_d -> function prog4 program_d
Rule 9     program_d -> empty
Rule 10    prog1 -> <empty>
Rule 11    prog2 -> <empty>
Rule 12    prog3 -> <empty>
Rule 13    prog4 -> <empty>
Rule 14    type -> atomic type3
Rule 15    typeM -> LC CTE_I RC LC CTE_I RC atomic type1
Rule 16    typeM -> LC CTE_I RC atomic type2
Rule 17    typeM -> ID type4
Rule 18    type1 -> <empty>
Rule 19    type2 -> <empty>
Rule 20    type3 -> <empty>
Rule 21    type4 -> <empty>
Rule 22    atomic -> INT atomic_type
Rule 23    atomic -> FLOAT atomic_type
Rule 24    atomic -> BOOL atomic_type
Rule 25    atomic_type -> <empty>
Rule 26    var -> VAR ID var1 COL type var2 var_a SEMICOL
Rule 27    var -> VAR ID var1 COL typeM SEMICOL var2
Rule 28    var_a -> IS var_b var3
Rule 29    var_a -> empty
Rule 30    var_b -> var_c type3
Rule 31    var_c -> CTE_I
Rule 32    var_c -> CTE_F
Rule 33    var_c -> CTE_B
Rule 34    var1 -> <empty>
Rule 35    var2 -> <empty>
Rule 36    var3 -> <empty>
Rule 37    let -> LET ID COL type IS var_b SEMICOL
Rule 38    main -> MAIN LP RP function_block
Rule 39    function -> FUNCTION ID LP params RP function_a function_block
Rule 40    function_a -> ARROW type
Rule 41    function_a -> empty
Rule 42    params -> ID COL type params_a
Rule 43    params -> empty
Rule 44    params_a -> COMMA params
Rule 45    params_a -> empty
Rule 46    block -> LB block_a RB
Rule 47    block_a -> statement block_a
Rule 48    block_a -> empty
Rule 49    function_block -> LB function_block_a block_a RB
Rule 50    function_block_a -> function_block_b function_block_a
Rule 51    function_block_a -> empty
Rule 52    function_block_b -> var
Rule 53    function_block_b -> let
Rule 54    class -> CLASS ID class_a LB class_b init class_c class_d RB
Rule 55    class_a -> COL ID
Rule 56    class_a -> empty
Rule 57    class_b -> class_e class_f class_b
Rule 58    class_b -> empty
Rule 59    class_e -> PRIVATE
Rule 60    class_e -> empty
Rule 61    class_f -> var
Rule 62    class_f -> let
Rule 63    class_c -> init class_c
Rule 64    class_c -> empty
Rule 65    class_d -> class_e function class_d
Rule 66    class_d -> empty
Rule 67    init -> INIT LP params RP block
Rule 68    statement -> print
Rule 69    statement -> input
Rule 70    statement -> assignment
Rule 71    statement -> condition
Rule 72    statement -> loop
Rule 73    statement -> call_function
Rule 74    statement -> return
Rule 75    return -> RETURN expression SEMICOL
Rule 76    obj -> ID array attribute
Rule 77    assignment -> obj IS expression SEMICOL
Rule 78    print -> PRINT LP print_a RP SEMICOL
Rule 79    print_a -> expression
Rule 80    print_a -> CTE_S
Rule 81    print_a -> empty
Rule 82    input -> INPUT LP obj RP SEMICOL
Rule 83    loop -> WHILE expression block
Rule 84    call_function -> obj call_func SEMICOL
Rule 85    call_params -> expression call_params_a
Rule 86    call_params -> empty
Rule 87    call_params_a -> COMMA expression call_params_a
Rule 88    call_params_a -> empty
Rule 89    condition -> IF expression block condition_a condition_b
Rule 90    condition_a -> elseif condition_a
Rule 91    condition_a -> empty
Rule 92    condition_b -> else
Rule 93    condition_b -> empty
Rule 94    elseif -> ELSEIF expression block
Rule 95    else -> ELSE block
Rule 96    expression -> comparison expression_a
Rule 97    expression_a -> AND comparison expression_a
Rule 98    expression_a -> OR comparison
Rule 99    expression_a -> empty
Rule 100   comparison -> exp comparison_a
Rule 101   comparison_a -> comparison_b exp comparison_a
Rule 102   comparison_a -> empty
Rule 103   comparison_b -> GEQ
Rule 104   comparison_b -> LEQ
Rule 105   comparison_b -> GT
Rule 106   comparison_b -> LT
Rule 107   comparison_b -> EQUAL
Rule 108   comparison_b -> NEQ
Rule 109   exp -> term exp_a
Rule 110   exp_a -> PLUS term exp_a
Rule 111   exp_a -> MINUS term exp_a
Rule 112   exp_a -> empty
Rule 113   term -> factor term_a
Rule 114   term_a -> MUL factor term_a
Rule 115   term_a -> DIV factor term_a
Rule 116   term_a -> empty
Rule 117   factor -> LP expression RP
Rule 118   factor -> factor_a var_cte
Rule 119   factor_a -> MINUS
Rule 120   factor_a -> NOT
Rule 121   factor_a -> empty
Rule 122   var_cte -> obj call_func_optional
Rule 123   var_cte -> CTE_I
Rule 124   var_cte -> CTE_F
Rule 125   var_cte -> CTE_B
Rule 126   array -> LC expression RC array_a
Rule 127   array -> empty
Rule 128   array_a -> LC expression RC
Rule 129   array_a -> empty
Rule 130   attribute -> DOT ID
Rule 131   attribute -> empty
Rule 132   call_func -> LP call_params RP
Rule 133   call_func_optional -> call_func
Rule 134   call_func_optional -> empty
Rule 135   empty -> <empty>

Terminals, with rules where they appear

AND                  : 97
ARROW                : 40
BOOL                 : 24
CLASS                : 54
COL                  : 26 27 37 42 55
COMMA                : 44 87
CTE_B                : 33 125
CTE_F                : 32 124
CTE_I                : 15 15 16 31 123
CTE_S                : 80
DIV                  : 115
DOT                  : 130
ELSE                 : 95
ELSEIF               : 94
EQUAL                : 107
FLOAT                : 23
FUNCTION             : 39
GEQ                  : 103
GT                   : 105
ID                   : 17 26 27 37 39 42 54 55 76 130
IF                   : 89
INIT                 : 67
INPUT                : 82
INT                  : 22
IS                   : 28 37 77
LB                   : 46 49 54
LC                   : 15 15 16 126 128
LEQ                  : 104
LET                  : 37
LP                   : 38 39 67 78 82 117 132
LT                   : 106
MAIN                 : 38
MINUS                : 111 119
MUL                  : 114
NEQ                  : 108
NOT                  : 120
OR                   : 98
PLUS                 : 110
PRINT                : 78
PRIVATE              : 59
RB                   : 46 49 54
RC                   : 15 15 16 126 128
RETURN               : 75
RP                   : 38 39 67 78 82 117 132
SEMICOL              : 26 27 37 75 77 78 82 84
VAR                  : 26 27
WHILE                : 83
error                : 

Nonterminals, with rules where they appear

array                : 76
array_a              : 126
assignment           : 70
atomic               : 14 15 16
atomic_type          : 22 23 24
attribute            : 76
block                : 67 83 89 94 95
block_a              : 46 47 49
call_func            : 84 133
call_func_optional   : 122
call_function        : 73
call_params          : 132
call_params_a        : 85 87
class                : 5
class_a              : 54
class_b              : 54 57
class_c              : 54 63
class_d              : 54 65
class_e              : 57 65
class_f              : 57
comparison           : 96 97 98
comparison_a         : 100 101
comparison_b         : 101
condition            : 71
condition_a          : 89 90
condition_b          : 89
else                 : 92
elseif               : 90
empty                : 3 7 9 29 41 43 45 48 51 56 58 60 64 66 81 86 88 91 93 99 102 112 116 121 127 129 131 134
exp                  : 100 101
exp_a                : 109 110 111
expression           : 75 77 79 83 85 87 89 94 117 126 128
expression_a         : 96 97
factor               : 113 114 115
factor_a             : 118
function             : 8 65
function_a           : 39
function_block       : 38 39
function_block_a     : 49 50
function_block_b     : 50
init                 : 54 63
input                : 69
let                  : 4 53 62
loop                 : 72
main                 : 1
obj                  : 77 82 84 122
params               : 39 44 67
params_a             : 42
print                : 68
print_a              : 78
prog1                : 4
prog2                : 5
prog3                : 6
prog4                : 8
program              : 0
program_a            : 1 2
program_b            : 2
program_c            : 1 6
program_d            : 1 8
return               : 74
statement            : 47
term                 : 109 110 111
term_a               : 113 114 115
type                 : 26 37 40 42
type1                : 15
type2                : 16
type3                : 14 30
type4                : 17
typeM                : 27
var                  : 6 52 61
var1                 : 26 27
var2                 : 26 27
var3                 : 28
var_a                : 26
var_b                : 28 37
var_c                : 30
var_cte              : 118

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . program_a program_c program_d main
    (2) program_a -> . program_b program_a
    (3) program_a -> . empty
    (4) program_b -> . let prog1
    (5) program_b -> . class prog2
    (135) empty -> .
    (37) let -> . LET ID COL type IS var_b SEMICOL
    (54) class -> . CLASS ID class_a LB class_b init class_c class_d RB

    VAR             reduce using rule 135 (empty -> .)
    FUNCTION        reduce using rule 135 (empty -> .)
    MAIN            reduce using rule 135 (empty -> .)
    LET             shift and go to state 7
    CLASS           shift and go to state 8

    program                        shift and go to state 1
    program_a                      shift and go to state 2
    program_b                      shift and go to state 3
    empty                          shift and go to state 4
    let                            shift and go to state 5
    class                          shift and go to state 6

state 1

    (0) S' -> program .



state 2

    (1) program -> program_a . program_c program_d main
    (6) program_c -> . var prog3 program_c
    (7) program_c -> . empty
    (26) var -> . VAR ID var1 COL type var2 var_a SEMICOL
    (27) var -> . VAR ID var1 COL typeM SEMICOL var2
    (135) empty -> .

    VAR             shift and go to state 12
    FUNCTION        reduce using rule 135 (empty -> .)
    MAIN            reduce using rule 135 (empty -> .)

    program_c                      shift and go to state 9
    var                            shift and go to state 10
    empty                          shift and go to state 11

state 3

    (2) program_a -> program_b . program_a
    (2) program_a -> . program_b program_a
    (3) program_a -> . empty
    (4) program_b -> . let prog1
    (5) program_b -> . class prog2
    (135) empty -> .
    (37) let -> . LET ID COL type IS var_b SEMICOL
    (54) class -> . CLASS ID class_a LB class_b init class_c class_d RB

    VAR             reduce using rule 135 (empty -> .)
    FUNCTION        reduce using rule 135 (empty -> .)
    MAIN            reduce using rule 135 (empty -> .)
    LET             shift and go to state 7
    CLASS           shift and go to state 8

    program_b                      shift and go to state 3
    program_a                      shift and go to state 13
    empty                          shift and go to state 4
    let                            shift and go to state 5
    class                          shift and go to state 6

state 4

    (3) program_a -> empty .

    VAR             reduce using rule 3 (program_a -> empty .)
    FUNCTION        reduce using rule 3 (program_a -> empty .)
    MAIN            reduce using rule 3 (program_a -> empty .)


state 5

    (4) program_b -> let . prog1
    (10) prog1 -> .

    LET             reduce using rule 10 (prog1 -> .)
    CLASS           reduce using rule 10 (prog1 -> .)
    VAR             reduce using rule 10 (prog1 -> .)
    FUNCTION        reduce using rule 10 (prog1 -> .)
    MAIN            reduce using rule 10 (prog1 -> .)

    prog1                          shift and go to state 14

state 6

    (5) program_b -> class . prog2
    (11) prog2 -> .

    LET             reduce using rule 11 (prog2 -> .)
    CLASS           reduce using rule 11 (prog2 -> .)
    VAR             reduce using rule 11 (prog2 -> .)
    FUNCTION        reduce using rule 11 (prog2 -> .)
    MAIN            reduce using rule 11 (prog2 -> .)

    prog2                          shift and go to state 15

state 7

    (37) let -> LET . ID COL type IS var_b SEMICOL

    ID              shift and go to state 16


state 8

    (54) class -> CLASS . ID class_a LB class_b init class_c class_d RB

    ID              shift and go to state 17


state 9

    (1) program -> program_a program_c . program_d main
    (8) program_d -> . function prog4 program_d
    (9) program_d -> . empty
    (39) function -> . FUNCTION ID LP params RP function_a function_block
    (135) empty -> .

    FUNCTION        shift and go to state 21
    MAIN            reduce using rule 135 (empty -> .)

    program_d                      shift and go to state 18
    function                       shift and go to state 19
    empty                          shift and go to state 20

state 10

    (6) program_c -> var . prog3 program_c
    (12) prog3 -> .

    VAR             reduce using rule 12 (prog3 -> .)
    FUNCTION        reduce using rule 12 (prog3 -> .)
    MAIN            reduce using rule 12 (prog3 -> .)

    prog3                          shift and go to state 22

state 11

    (7) program_c -> empty .

    FUNCTION        reduce using rule 7 (program_c -> empty .)
    MAIN            reduce using rule 7 (program_c -> empty .)


state 12

    (26) var -> VAR . ID var1 COL type var2 var_a SEMICOL
    (27) var -> VAR . ID var1 COL typeM SEMICOL var2

    ID              shift and go to state 23


state 13

    (2) program_a -> program_b program_a .

    VAR             reduce using rule 2 (program_a -> program_b program_a .)
    FUNCTION        reduce using rule 2 (program_a -> program_b program_a .)
    MAIN            reduce using rule 2 (program_a -> program_b program_a .)


state 14

    (4) program_b -> let prog1 .

    LET             reduce using rule 4 (program_b -> let prog1 .)
    CLASS           reduce using rule 4 (program_b -> let prog1 .)
    VAR             reduce using rule 4 (program_b -> let prog1 .)
    FUNCTION        reduce using rule 4 (program_b -> let prog1 .)
    MAIN            reduce using rule 4 (program_b -> let prog1 .)


state 15

    (5) program_b -> class prog2 .

    LET             reduce using rule 5 (program_b -> class prog2 .)
    CLASS           reduce using rule 5 (program_b -> class prog2 .)
    VAR             reduce using rule 5 (program_b -> class prog2 .)
    FUNCTION        reduce using rule 5 (program_b -> class prog2 .)
    MAIN            reduce using rule 5 (program_b -> class prog2 .)


state 16

    (37) let -> LET ID . COL type IS var_b SEMICOL

    COL             shift and go to state 24


state 17

    (54) class -> CLASS ID . class_a LB class_b init class_c class_d RB
    (55) class_a -> . COL ID
    (56) class_a -> . empty
    (135) empty -> .

    COL             shift and go to state 26
    LB              reduce using rule 135 (empty -> .)

    class_a                        shift and go to state 25
    empty                          shift and go to state 27

state 18

    (1) program -> program_a program_c program_d . main
    (38) main -> . MAIN LP RP function_block

    MAIN            shift and go to state 29

    main                           shift and go to state 28

state 19

    (8) program_d -> function . prog4 program_d
    (13) prog4 -> .

    FUNCTION        reduce using rule 13 (prog4 -> .)
    MAIN            reduce using rule 13 (prog4 -> .)

    prog4                          shift and go to state 30

state 20

    (9) program_d -> empty .

    MAIN            reduce using rule 9 (program_d -> empty .)


state 21

    (39) function -> FUNCTION . ID LP params RP function_a function_block

    ID              shift and go to state 31


state 22

    (6) program_c -> var prog3 . program_c
    (6) program_c -> . var prog3 program_c
    (7) program_c -> . empty
    (26) var -> . VAR ID var1 COL type var2 var_a SEMICOL
    (27) var -> . VAR ID var1 COL typeM SEMICOL var2
    (135) empty -> .

    VAR             shift and go to state 12
    FUNCTION        reduce using rule 135 (empty -> .)
    MAIN            reduce using rule 135 (empty -> .)

    var                            shift and go to state 10
    program_c                      shift and go to state 32
    empty                          shift and go to state 11

state 23

    (26) var -> VAR ID . var1 COL type var2 var_a SEMICOL
    (27) var -> VAR ID . var1 COL typeM SEMICOL var2
    (34) var1 -> .

    COL             reduce using rule 34 (var1 -> .)

    var1                           shift and go to state 33

state 24

    (37) let -> LET ID COL . type IS var_b SEMICOL
    (14) type -> . atomic type3
    (22) atomic -> . INT atomic_type
    (23) atomic -> . FLOAT atomic_type
    (24) atomic -> . BOOL atomic_type

    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    BOOL            shift and go to state 38

    type                           shift and go to state 34
    atomic                         shift and go to state 35

state 25

    (54) class -> CLASS ID class_a . LB class_b init class_c class_d RB

    LB              shift and go to state 39


state 26

    (55) class_a -> COL . ID

    ID              shift and go to state 40


state 27

    (56) class_a -> empty .

    LB              reduce using rule 56 (class_a -> empty .)


state 28

    (1) program -> program_a program_c program_d main .

    $end            reduce using rule 1 (program -> program_a program_c program_d main .)


state 29

    (38) main -> MAIN . LP RP function_block

    LP              shift and go to state 41


state 30

    (8) program_d -> function prog4 . program_d
    (8) program_d -> . function prog4 program_d
    (9) program_d -> . empty
    (39) function -> . FUNCTION ID LP params RP function_a function_block
    (135) empty -> .

    FUNCTION        shift and go to state 21
    MAIN            reduce using rule 135 (empty -> .)

    function                       shift and go to state 19
    program_d                      shift and go to state 42
    empty                          shift and go to state 20

state 31

    (39) function -> FUNCTION ID . LP params RP function_a function_block

    LP              shift and go to state 43


state 32

    (6) program_c -> var prog3 program_c .

    FUNCTION        reduce using rule 6 (program_c -> var prog3 program_c .)
    MAIN            reduce using rule 6 (program_c -> var prog3 program_c .)


state 33

    (26) var -> VAR ID var1 . COL type var2 var_a SEMICOL
    (27) var -> VAR ID var1 . COL typeM SEMICOL var2

    COL             shift and go to state 44


state 34

    (37) let -> LET ID COL type . IS var_b SEMICOL

    IS              shift and go to state 45


state 35

    (14) type -> atomic . type3
    (20) type3 -> .

    IS              reduce using rule 20 (type3 -> .)
    SEMICOL         reduce using rule 20 (type3 -> .)
    COMMA           reduce using rule 20 (type3 -> .)
    RP              reduce using rule 20 (type3 -> .)
    LB              reduce using rule 20 (type3 -> .)

    type3                          shift and go to state 46

state 36

    (22) atomic -> INT . atomic_type
    (25) atomic_type -> .

    IS              reduce using rule 25 (atomic_type -> .)
    SEMICOL         reduce using rule 25 (atomic_type -> .)
    COMMA           reduce using rule 25 (atomic_type -> .)
    RP              reduce using rule 25 (atomic_type -> .)
    LB              reduce using rule 25 (atomic_type -> .)

    atomic_type                    shift and go to state 47

state 37

    (23) atomic -> FLOAT . atomic_type
    (25) atomic_type -> .

    IS              reduce using rule 25 (atomic_type -> .)
    SEMICOL         reduce using rule 25 (atomic_type -> .)
    COMMA           reduce using rule 25 (atomic_type -> .)
    RP              reduce using rule 25 (atomic_type -> .)
    LB              reduce using rule 25 (atomic_type -> .)

    atomic_type                    shift and go to state 48

state 38

    (24) atomic -> BOOL . atomic_type
    (25) atomic_type -> .

    IS              reduce using rule 25 (atomic_type -> .)
    SEMICOL         reduce using rule 25 (atomic_type -> .)
    COMMA           reduce using rule 25 (atomic_type -> .)
    RP              reduce using rule 25 (atomic_type -> .)
    LB              reduce using rule 25 (atomic_type -> .)

    atomic_type                    shift and go to state 49

state 39

    (54) class -> CLASS ID class_a LB . class_b init class_c class_d RB
    (57) class_b -> . class_e class_f class_b
    (58) class_b -> . empty
    (59) class_e -> . PRIVATE
    (60) class_e -> . empty
    (135) empty -> .

    PRIVATE         shift and go to state 53
    INIT            reduce using rule 135 (empty -> .)
    VAR             reduce using rule 135 (empty -> .)
    LET             reduce using rule 135 (empty -> .)

    class_b                        shift and go to state 50
    class_e                        shift and go to state 51
    empty                          shift and go to state 52

state 40

    (55) class_a -> COL ID .

    LB              reduce using rule 55 (class_a -> COL ID .)


state 41

    (38) main -> MAIN LP . RP function_block

    RP              shift and go to state 54


state 42

    (8) program_d -> function prog4 program_d .

    MAIN            reduce using rule 8 (program_d -> function prog4 program_d .)


state 43

    (39) function -> FUNCTION ID LP . params RP function_a function_block
    (42) params -> . ID COL type params_a
    (43) params -> . empty
    (135) empty -> .

    ID              shift and go to state 55
    RP              reduce using rule 135 (empty -> .)

    params                         shift and go to state 56
    empty                          shift and go to state 57

state 44

    (26) var -> VAR ID var1 COL . type var2 var_a SEMICOL
    (27) var -> VAR ID var1 COL . typeM SEMICOL var2
    (14) type -> . atomic type3
    (15) typeM -> . LC CTE_I RC LC CTE_I RC atomic type1
    (16) typeM -> . LC CTE_I RC atomic type2
    (17) typeM -> . ID type4
    (22) atomic -> . INT atomic_type
    (23) atomic -> . FLOAT atomic_type
    (24) atomic -> . BOOL atomic_type

    LC              shift and go to state 61
    ID              shift and go to state 58
    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    BOOL            shift and go to state 38

    type                           shift and go to state 59
    typeM                          shift and go to state 60
    atomic                         shift and go to state 35

state 45

    (37) let -> LET ID COL type IS . var_b SEMICOL
    (30) var_b -> . var_c type3
    (31) var_c -> . CTE_I
    (32) var_c -> . CTE_F
    (33) var_c -> . CTE_B

    CTE_I           shift and go to state 64
    CTE_F           shift and go to state 65
    CTE_B           shift and go to state 66

    var_b                          shift and go to state 62
    var_c                          shift and go to state 63

state 46

    (14) type -> atomic type3 .

    IS              reduce using rule 14 (type -> atomic type3 .)
    SEMICOL         reduce using rule 14 (type -> atomic type3 .)
    COMMA           reduce using rule 14 (type -> atomic type3 .)
    RP              reduce using rule 14 (type -> atomic type3 .)
    LB              reduce using rule 14 (type -> atomic type3 .)


state 47

    (22) atomic -> INT atomic_type .

    IS              reduce using rule 22 (atomic -> INT atomic_type .)
    SEMICOL         reduce using rule 22 (atomic -> INT atomic_type .)
    COMMA           reduce using rule 22 (atomic -> INT atomic_type .)
    RP              reduce using rule 22 (atomic -> INT atomic_type .)
    LB              reduce using rule 22 (atomic -> INT atomic_type .)


state 48

    (23) atomic -> FLOAT atomic_type .

    IS              reduce using rule 23 (atomic -> FLOAT atomic_type .)
    SEMICOL         reduce using rule 23 (atomic -> FLOAT atomic_type .)
    COMMA           reduce using rule 23 (atomic -> FLOAT atomic_type .)
    RP              reduce using rule 23 (atomic -> FLOAT atomic_type .)
    LB              reduce using rule 23 (atomic -> FLOAT atomic_type .)


state 49

    (24) atomic -> BOOL atomic_type .

    IS              reduce using rule 24 (atomic -> BOOL atomic_type .)
    SEMICOL         reduce using rule 24 (atomic -> BOOL atomic_type .)
    COMMA           reduce using rule 24 (atomic -> BOOL atomic_type .)
    RP              reduce using rule 24 (atomic -> BOOL atomic_type .)
    LB              reduce using rule 24 (atomic -> BOOL atomic_type .)


state 50

    (54) class -> CLASS ID class_a LB class_b . init class_c class_d RB
    (67) init -> . INIT LP params RP block

    INIT            shift and go to state 68

    init                           shift and go to state 67

state 51

    (57) class_b -> class_e . class_f class_b
    (61) class_f -> . var
    (62) class_f -> . let
    (26) var -> . VAR ID var1 COL type var2 var_a SEMICOL
    (27) var -> . VAR ID var1 COL typeM SEMICOL var2
    (37) let -> . LET ID COL type IS var_b SEMICOL

    VAR             shift and go to state 12
    LET             shift and go to state 7

    class_f                        shift and go to state 69
    var                            shift and go to state 70
    let                            shift and go to state 71

state 52

    (58) class_b -> empty .
    (60) class_e -> empty .

    INIT            reduce using rule 58 (class_b -> empty .)
    VAR             reduce using rule 60 (class_e -> empty .)
    LET             reduce using rule 60 (class_e -> empty .)


state 53

    (59) class_e -> PRIVATE .

    VAR             reduce using rule 59 (class_e -> PRIVATE .)
    LET             reduce using rule 59 (class_e -> PRIVATE .)
    FUNCTION        reduce using rule 59 (class_e -> PRIVATE .)


state 54

    (38) main -> MAIN LP RP . function_block
    (49) function_block -> . LB function_block_a block_a RB

    LB              shift and go to state 73

    function_block                 shift and go to state 72

state 55

    (42) params -> ID . COL type params_a

    COL             shift and go to state 74


state 56

    (39) function -> FUNCTION ID LP params . RP function_a function_block

    RP              shift and go to state 75


state 57

    (43) params -> empty .

    RP              reduce using rule 43 (params -> empty .)


state 58

    (17) typeM -> ID . type4
    (21) type4 -> .

    SEMICOL         reduce using rule 21 (type4 -> .)

    type4                          shift and go to state 76

state 59

    (26) var -> VAR ID var1 COL type . var2 var_a SEMICOL
    (35) var2 -> .

    IS              reduce using rule 35 (var2 -> .)
    SEMICOL         reduce using rule 35 (var2 -> .)

    var2                           shift and go to state 77

state 60

    (27) var -> VAR ID var1 COL typeM . SEMICOL var2

    SEMICOL         shift and go to state 78


state 61

    (15) typeM -> LC . CTE_I RC LC CTE_I RC atomic type1
    (16) typeM -> LC . CTE_I RC atomic type2

    CTE_I           shift and go to state 79


state 62

    (37) let -> LET ID COL type IS var_b . SEMICOL

    SEMICOL         shift and go to state 80


state 63

    (30) var_b -> var_c . type3
    (20) type3 -> .

    SEMICOL         reduce using rule 20 (type3 -> .)

    type3                          shift and go to state 81

state 64

    (31) var_c -> CTE_I .

    SEMICOL         reduce using rule 31 (var_c -> CTE_I .)


state 65

    (32) var_c -> CTE_F .

    SEMICOL         reduce using rule 32 (var_c -> CTE_F .)


state 66

    (33) var_c -> CTE_B .

    SEMICOL         reduce using rule 33 (var_c -> CTE_B .)


state 67

    (54) class -> CLASS ID class_a LB class_b init . class_c class_d RB
    (63) class_c -> . init class_c
    (64) class_c -> . empty
    (67) init -> . INIT LP params RP block
    (135) empty -> .

    INIT            shift and go to state 68
    PRIVATE         reduce using rule 135 (empty -> .)
    RB              reduce using rule 135 (empty -> .)
    FUNCTION        reduce using rule 135 (empty -> .)

    init                           shift and go to state 82
    class_c                        shift and go to state 83
    empty                          shift and go to state 84

state 68

    (67) init -> INIT . LP params RP block

    LP              shift and go to state 85


state 69

    (57) class_b -> class_e class_f . class_b
    (57) class_b -> . class_e class_f class_b
    (58) class_b -> . empty
    (59) class_e -> . PRIVATE
    (60) class_e -> . empty
    (135) empty -> .

    PRIVATE         shift and go to state 53
    INIT            reduce using rule 135 (empty -> .)
    VAR             reduce using rule 135 (empty -> .)
    LET             reduce using rule 135 (empty -> .)

    class_e                        shift and go to state 51
    class_b                        shift and go to state 86
    empty                          shift and go to state 52

state 70

    (61) class_f -> var .

    PRIVATE         reduce using rule 61 (class_f -> var .)
    VAR             reduce using rule 61 (class_f -> var .)
    LET             reduce using rule 61 (class_f -> var .)
    INIT            reduce using rule 61 (class_f -> var .)


state 71

    (62) class_f -> let .

    PRIVATE         reduce using rule 62 (class_f -> let .)
    VAR             reduce using rule 62 (class_f -> let .)
    LET             reduce using rule 62 (class_f -> let .)
    INIT            reduce using rule 62 (class_f -> let .)


state 72

    (38) main -> MAIN LP RP function_block .

    $end            reduce using rule 38 (main -> MAIN LP RP function_block .)


state 73

    (49) function_block -> LB . function_block_a block_a RB
    (50) function_block_a -> . function_block_b function_block_a
    (51) function_block_a -> . empty
    (52) function_block_b -> . var
    (53) function_block_b -> . let
    (135) empty -> .
    (26) var -> . VAR ID var1 COL type var2 var_a SEMICOL
    (27) var -> . VAR ID var1 COL typeM SEMICOL var2
    (37) let -> . LET ID COL type IS var_b SEMICOL

    PRINT           reduce using rule 135 (empty -> .)
    INPUT           reduce using rule 135 (empty -> .)
    IF              reduce using rule 135 (empty -> .)
    WHILE           reduce using rule 135 (empty -> .)
    RETURN          reduce using rule 135 (empty -> .)
    ID              reduce using rule 135 (empty -> .)
    RB              reduce using rule 135 (empty -> .)
    VAR             shift and go to state 12
    LET             shift and go to state 7

    function_block_a               shift and go to state 87
    function_block_b               shift and go to state 88
    empty                          shift and go to state 89
    var                            shift and go to state 90
    let                            shift and go to state 91

state 74

    (42) params -> ID COL . type params_a
    (14) type -> . atomic type3
    (22) atomic -> . INT atomic_type
    (23) atomic -> . FLOAT atomic_type
    (24) atomic -> . BOOL atomic_type

    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    BOOL            shift and go to state 38

    type                           shift and go to state 92
    atomic                         shift and go to state 35

state 75

    (39) function -> FUNCTION ID LP params RP . function_a function_block
    (40) function_a -> . ARROW type
    (41) function_a -> . empty
    (135) empty -> .

    ARROW           shift and go to state 94
    LB              reduce using rule 135 (empty -> .)

    function_a                     shift and go to state 93
    empty                          shift and go to state 95

state 76

    (17) typeM -> ID type4 .

    SEMICOL         reduce using rule 17 (typeM -> ID type4 .)


state 77

    (26) var -> VAR ID var1 COL type var2 . var_a SEMICOL
    (28) var_a -> . IS var_b var3
    (29) var_a -> . empty
    (135) empty -> .

    IS              shift and go to state 97
    SEMICOL         reduce using rule 135 (empty -> .)

    var_a                          shift and go to state 96
    empty                          shift and go to state 98

state 78

    (27) var -> VAR ID var1 COL typeM SEMICOL . var2
    (35) var2 -> .

    VAR             reduce using rule 35 (var2 -> .)
    FUNCTION        reduce using rule 35 (var2 -> .)
    MAIN            reduce using rule 35 (var2 -> .)
    PRIVATE         reduce using rule 35 (var2 -> .)
    LET             reduce using rule 35 (var2 -> .)
    INIT            reduce using rule 35 (var2 -> .)
    PRINT           reduce using rule 35 (var2 -> .)
    INPUT           reduce using rule 35 (var2 -> .)
    IF              reduce using rule 35 (var2 -> .)
    WHILE           reduce using rule 35 (var2 -> .)
    RETURN          reduce using rule 35 (var2 -> .)
    ID              reduce using rule 35 (var2 -> .)
    RB              reduce using rule 35 (var2 -> .)

    var2                           shift and go to state 99

state 79

    (15) typeM -> LC CTE_I . RC LC CTE_I RC atomic type1
    (16) typeM -> LC CTE_I . RC atomic type2

    RC              shift and go to state 100


state 80

    (37) let -> LET ID COL type IS var_b SEMICOL .

    LET             reduce using rule 37 (let -> LET ID COL type IS var_b SEMICOL .)
    CLASS           reduce using rule 37 (let -> LET ID COL type IS var_b SEMICOL .)
    VAR             reduce using rule 37 (let -> LET ID COL type IS var_b SEMICOL .)
    FUNCTION        reduce using rule 37 (let -> LET ID COL type IS var_b SEMICOL .)
    MAIN            reduce using rule 37 (let -> LET ID COL type IS var_b SEMICOL .)
    PRIVATE         reduce using rule 37 (let -> LET ID COL type IS var_b SEMICOL .)
    INIT            reduce using rule 37 (let -> LET ID COL type IS var_b SEMICOL .)
    PRINT           reduce using rule 37 (let -> LET ID COL type IS var_b SEMICOL .)
    INPUT           reduce using rule 37 (let -> LET ID COL type IS var_b SEMICOL .)
    IF              reduce using rule 37 (let -> LET ID COL type IS var_b SEMICOL .)
    WHILE           reduce using rule 37 (let -> LET ID COL type IS var_b SEMICOL .)
    RETURN          reduce using rule 37 (let -> LET ID COL type IS var_b SEMICOL .)
    ID              reduce using rule 37 (let -> LET ID COL type IS var_b SEMICOL .)
    RB              reduce using rule 37 (let -> LET ID COL type IS var_b SEMICOL .)


state 81

    (30) var_b -> var_c type3 .

    SEMICOL         reduce using rule 30 (var_b -> var_c type3 .)


state 82

    (63) class_c -> init . class_c
    (63) class_c -> . init class_c
    (64) class_c -> . empty
    (67) init -> . INIT LP params RP block
    (135) empty -> .

    INIT            shift and go to state 68
    PRIVATE         reduce using rule 135 (empty -> .)
    RB              reduce using rule 135 (empty -> .)
    FUNCTION        reduce using rule 135 (empty -> .)

    init                           shift and go to state 82
    class_c                        shift and go to state 101
    empty                          shift and go to state 84

state 83

    (54) class -> CLASS ID class_a LB class_b init class_c . class_d RB
    (65) class_d -> . class_e function class_d
    (66) class_d -> . empty
    (59) class_e -> . PRIVATE
    (60) class_e -> . empty
    (135) empty -> .

    PRIVATE         shift and go to state 53
    RB              reduce using rule 135 (empty -> .)
    FUNCTION        reduce using rule 135 (empty -> .)

    class_d                        shift and go to state 102
    class_e                        shift and go to state 103
    empty                          shift and go to state 104

state 84

    (64) class_c -> empty .

    PRIVATE         reduce using rule 64 (class_c -> empty .)
    RB              reduce using rule 64 (class_c -> empty .)
    FUNCTION        reduce using rule 64 (class_c -> empty .)


state 85

    (67) init -> INIT LP . params RP block
    (42) params -> . ID COL type params_a
    (43) params -> . empty
    (135) empty -> .

    ID              shift and go to state 55
    RP              reduce using rule 135 (empty -> .)

    params                         shift and go to state 105
    empty                          shift and go to state 57

state 86

    (57) class_b -> class_e class_f class_b .

    INIT            reduce using rule 57 (class_b -> class_e class_f class_b .)


state 87

    (49) function_block -> LB function_block_a . block_a RB
    (47) block_a -> . statement block_a
    (48) block_a -> . empty
    (68) statement -> . print
    (69) statement -> . input
    (70) statement -> . assignment
    (71) statement -> . condition
    (72) statement -> . loop
    (73) statement -> . call_function
    (74) statement -> . return
    (135) empty -> .
    (78) print -> . PRINT LP print_a RP SEMICOL
    (82) input -> . INPUT LP obj RP SEMICOL
    (77) assignment -> . obj IS expression SEMICOL
    (89) condition -> . IF expression block condition_a condition_b
    (83) loop -> . WHILE expression block
    (84) call_function -> . obj call_func SEMICOL
    (75) return -> . RETURN expression SEMICOL
    (76) obj -> . ID array attribute

    RB              reduce using rule 135 (empty -> .)
    PRINT           shift and go to state 116
    INPUT           shift and go to state 117
    IF              shift and go to state 119
    WHILE           shift and go to state 120
    RETURN          shift and go to state 121
    ID              shift and go to state 122

    block_a                        shift and go to state 106
    statement                      shift and go to state 107
    empty                          shift and go to state 108
    print                          shift and go to state 109
    input                          shift and go to state 110
    assignment                     shift and go to state 111
    condition                      shift and go to state 112
    loop                           shift and go to state 113
    call_function                  shift and go to state 114
    return                         shift and go to state 115
    obj                            shift and go to state 118

state 88

    (50) function_block_a -> function_block_b . function_block_a
    (50) function_block_a -> . function_block_b function_block_a
    (51) function_block_a -> . empty
    (52) function_block_b -> . var
    (53) function_block_b -> . let
    (135) empty -> .
    (26) var -> . VAR ID var1 COL type var2 var_a SEMICOL
    (27) var -> . VAR ID var1 COL typeM SEMICOL var2
    (37) let -> . LET ID COL type IS var_b SEMICOL

    PRINT           reduce using rule 135 (empty -> .)
    INPUT           reduce using rule 135 (empty -> .)
    IF              reduce using rule 135 (empty -> .)
    WHILE           reduce using rule 135 (empty -> .)
    RETURN          reduce using rule 135 (empty -> .)
    ID              reduce using rule 135 (empty -> .)
    RB              reduce using rule 135 (empty -> .)
    VAR             shift and go to state 12
    LET             shift and go to state 7

    function_block_b               shift and go to state 88
    function_block_a               shift and go to state 123
    empty                          shift and go to state 89
    var                            shift and go to state 90
    let                            shift and go to state 91

state 89

    (51) function_block_a -> empty .

    PRINT           reduce using rule 51 (function_block_a -> empty .)
    INPUT           reduce using rule 51 (function_block_a -> empty .)
    IF              reduce using rule 51 (function_block_a -> empty .)
    WHILE           reduce using rule 51 (function_block_a -> empty .)
    RETURN          reduce using rule 51 (function_block_a -> empty .)
    ID              reduce using rule 51 (function_block_a -> empty .)
    RB              reduce using rule 51 (function_block_a -> empty .)


state 90

    (52) function_block_b -> var .

    VAR             reduce using rule 52 (function_block_b -> var .)
    LET             reduce using rule 52 (function_block_b -> var .)
    PRINT           reduce using rule 52 (function_block_b -> var .)
    INPUT           reduce using rule 52 (function_block_b -> var .)
    IF              reduce using rule 52 (function_block_b -> var .)
    WHILE           reduce using rule 52 (function_block_b -> var .)
    RETURN          reduce using rule 52 (function_block_b -> var .)
    ID              reduce using rule 52 (function_block_b -> var .)
    RB              reduce using rule 52 (function_block_b -> var .)


state 91

    (53) function_block_b -> let .

    VAR             reduce using rule 53 (function_block_b -> let .)
    LET             reduce using rule 53 (function_block_b -> let .)
    PRINT           reduce using rule 53 (function_block_b -> let .)
    INPUT           reduce using rule 53 (function_block_b -> let .)
    IF              reduce using rule 53 (function_block_b -> let .)
    WHILE           reduce using rule 53 (function_block_b -> let .)
    RETURN          reduce using rule 53 (function_block_b -> let .)
    ID              reduce using rule 53 (function_block_b -> let .)
    RB              reduce using rule 53 (function_block_b -> let .)


state 92

    (42) params -> ID COL type . params_a
    (44) params_a -> . COMMA params
    (45) params_a -> . empty
    (135) empty -> .

    COMMA           shift and go to state 125
    RP              reduce using rule 135 (empty -> .)

    params_a                       shift and go to state 124
    empty                          shift and go to state 126

state 93

    (39) function -> FUNCTION ID LP params RP function_a . function_block
    (49) function_block -> . LB function_block_a block_a RB

    LB              shift and go to state 73

    function_block                 shift and go to state 127

state 94

    (40) function_a -> ARROW . type
    (14) type -> . atomic type3
    (22) atomic -> . INT atomic_type
    (23) atomic -> . FLOAT atomic_type
    (24) atomic -> . BOOL atomic_type

    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    BOOL            shift and go to state 38

    type                           shift and go to state 128
    atomic                         shift and go to state 35

state 95

    (41) function_a -> empty .

    LB              reduce using rule 41 (function_a -> empty .)


state 96

    (26) var -> VAR ID var1 COL type var2 var_a . SEMICOL

    SEMICOL         shift and go to state 129


state 97

    (28) var_a -> IS . var_b var3
    (30) var_b -> . var_c type3
    (31) var_c -> . CTE_I
    (32) var_c -> . CTE_F
    (33) var_c -> . CTE_B

    CTE_I           shift and go to state 64
    CTE_F           shift and go to state 65
    CTE_B           shift and go to state 66

    var_b                          shift and go to state 130
    var_c                          shift and go to state 63

state 98

    (29) var_a -> empty .

    SEMICOL         reduce using rule 29 (var_a -> empty .)


state 99

    (27) var -> VAR ID var1 COL typeM SEMICOL var2 .

    VAR             reduce using rule 27 (var -> VAR ID var1 COL typeM SEMICOL var2 .)
    FUNCTION        reduce using rule 27 (var -> VAR ID var1 COL typeM SEMICOL var2 .)
    MAIN            reduce using rule 27 (var -> VAR ID var1 COL typeM SEMICOL var2 .)
    PRIVATE         reduce using rule 27 (var -> VAR ID var1 COL typeM SEMICOL var2 .)
    LET             reduce using rule 27 (var -> VAR ID var1 COL typeM SEMICOL var2 .)
    INIT            reduce using rule 27 (var -> VAR ID var1 COL typeM SEMICOL var2 .)
    PRINT           reduce using rule 27 (var -> VAR ID var1 COL typeM SEMICOL var2 .)
    INPUT           reduce using rule 27 (var -> VAR ID var1 COL typeM SEMICOL var2 .)
    IF              reduce using rule 27 (var -> VAR ID var1 COL typeM SEMICOL var2 .)
    WHILE           reduce using rule 27 (var -> VAR ID var1 COL typeM SEMICOL var2 .)
    RETURN          reduce using rule 27 (var -> VAR ID var1 COL typeM SEMICOL var2 .)
    ID              reduce using rule 27 (var -> VAR ID var1 COL typeM SEMICOL var2 .)
    RB              reduce using rule 27 (var -> VAR ID var1 COL typeM SEMICOL var2 .)


state 100

    (15) typeM -> LC CTE_I RC . LC CTE_I RC atomic type1
    (16) typeM -> LC CTE_I RC . atomic type2
    (22) atomic -> . INT atomic_type
    (23) atomic -> . FLOAT atomic_type
    (24) atomic -> . BOOL atomic_type

    LC              shift and go to state 131
    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    BOOL            shift and go to state 38

    atomic                         shift and go to state 132

state 101

    (63) class_c -> init class_c .

    PRIVATE         reduce using rule 63 (class_c -> init class_c .)
    RB              reduce using rule 63 (class_c -> init class_c .)
    FUNCTION        reduce using rule 63 (class_c -> init class_c .)


state 102

    (54) class -> CLASS ID class_a LB class_b init class_c class_d . RB

    RB              shift and go to state 133


state 103

    (65) class_d -> class_e . function class_d
    (39) function -> . FUNCTION ID LP params RP function_a function_block

    FUNCTION        shift and go to state 21

    function                       shift and go to state 134

state 104

    (66) class_d -> empty .
    (60) class_e -> empty .

    RB              reduce using rule 66 (class_d -> empty .)
    FUNCTION        reduce using rule 60 (class_e -> empty .)


state 105

    (67) init -> INIT LP params . RP block

    RP              shift and go to state 135


state 106

    (49) function_block -> LB function_block_a block_a . RB

    RB              shift and go to state 136


state 107

    (47) block_a -> statement . block_a
    (47) block_a -> . statement block_a
    (48) block_a -> . empty
    (68) statement -> . print
    (69) statement -> . input
    (70) statement -> . assignment
    (71) statement -> . condition
    (72) statement -> . loop
    (73) statement -> . call_function
    (74) statement -> . return
    (135) empty -> .
    (78) print -> . PRINT LP print_a RP SEMICOL
    (82) input -> . INPUT LP obj RP SEMICOL
    (77) assignment -> . obj IS expression SEMICOL
    (89) condition -> . IF expression block condition_a condition_b
    (83) loop -> . WHILE expression block
    (84) call_function -> . obj call_func SEMICOL
    (75) return -> . RETURN expression SEMICOL
    (76) obj -> . ID array attribute

    RB              reduce using rule 135 (empty -> .)
    PRINT           shift and go to state 116
    INPUT           shift and go to state 117
    IF              shift and go to state 119
    WHILE           shift and go to state 120
    RETURN          shift and go to state 121
    ID              shift and go to state 122

    statement                      shift and go to state 107
    block_a                        shift and go to state 137
    empty                          shift and go to state 108
    print                          shift and go to state 109
    input                          shift and go to state 110
    assignment                     shift and go to state 111
    condition                      shift and go to state 112
    loop                           shift and go to state 113
    call_function                  shift and go to state 114
    return                         shift and go to state 115
    obj                            shift and go to state 118

state 108

    (48) block_a -> empty .

    RB              reduce using rule 48 (block_a -> empty .)


state 109

    (68) statement -> print .

    PRINT           reduce using rule 68 (statement -> print .)
    INPUT           reduce using rule 68 (statement -> print .)
    IF              reduce using rule 68 (statement -> print .)
    WHILE           reduce using rule 68 (statement -> print .)
    RETURN          reduce using rule 68 (statement -> print .)
    ID              reduce using rule 68 (statement -> print .)
    RB              reduce using rule 68 (statement -> print .)


state 110

    (69) statement -> input .

    PRINT           reduce using rule 69 (statement -> input .)
    INPUT           reduce using rule 69 (statement -> input .)
    IF              reduce using rule 69 (statement -> input .)
    WHILE           reduce using rule 69 (statement -> input .)
    RETURN          reduce using rule 69 (statement -> input .)
    ID              reduce using rule 69 (statement -> input .)
    RB              reduce using rule 69 (statement -> input .)


state 111

    (70) statement -> assignment .

    PRINT           reduce using rule 70 (statement -> assignment .)
    INPUT           reduce using rule 70 (statement -> assignment .)
    IF              reduce using rule 70 (statement -> assignment .)
    WHILE           reduce using rule 70 (statement -> assignment .)
    RETURN          reduce using rule 70 (statement -> assignment .)
    ID              reduce using rule 70 (statement -> assignment .)
    RB              reduce using rule 70 (statement -> assignment .)


state 112

    (71) statement -> condition .

    PRINT           reduce using rule 71 (statement -> condition .)
    INPUT           reduce using rule 71 (statement -> condition .)
    IF              reduce using rule 71 (statement -> condition .)
    WHILE           reduce using rule 71 (statement -> condition .)
    RETURN          reduce using rule 71 (statement -> condition .)
    ID              reduce using rule 71 (statement -> condition .)
    RB              reduce using rule 71 (statement -> condition .)


state 113

    (72) statement -> loop .

    PRINT           reduce using rule 72 (statement -> loop .)
    INPUT           reduce using rule 72 (statement -> loop .)
    IF              reduce using rule 72 (statement -> loop .)
    WHILE           reduce using rule 72 (statement -> loop .)
    RETURN          reduce using rule 72 (statement -> loop .)
    ID              reduce using rule 72 (statement -> loop .)
    RB              reduce using rule 72 (statement -> loop .)


state 114

    (73) statement -> call_function .

    PRINT           reduce using rule 73 (statement -> call_function .)
    INPUT           reduce using rule 73 (statement -> call_function .)
    IF              reduce using rule 73 (statement -> call_function .)
    WHILE           reduce using rule 73 (statement -> call_function .)
    RETURN          reduce using rule 73 (statement -> call_function .)
    ID              reduce using rule 73 (statement -> call_function .)
    RB              reduce using rule 73 (statement -> call_function .)


state 115

    (74) statement -> return .

    PRINT           reduce using rule 74 (statement -> return .)
    INPUT           reduce using rule 74 (statement -> return .)
    IF              reduce using rule 74 (statement -> return .)
    WHILE           reduce using rule 74 (statement -> return .)
    RETURN          reduce using rule 74 (statement -> return .)
    ID              reduce using rule 74 (statement -> return .)
    RB              reduce using rule 74 (statement -> return .)


state 116

    (78) print -> PRINT . LP print_a RP SEMICOL

    LP              shift and go to state 138


state 117

    (82) input -> INPUT . LP obj RP SEMICOL

    LP              shift and go to state 139


state 118

    (77) assignment -> obj . IS expression SEMICOL
    (84) call_function -> obj . call_func SEMICOL
    (132) call_func -> . LP call_params RP

    IS              shift and go to state 140
    LP              shift and go to state 142

    call_func                      shift and go to state 141

state 119

    (89) condition -> IF . expression block condition_a condition_b
    (96) expression -> . comparison expression_a
    (100) comparison -> . exp comparison_a
    (109) exp -> . term exp_a
    (113) term -> . factor term_a
    (117) factor -> . LP expression RP
    (118) factor -> . factor_a var_cte
    (119) factor_a -> . MINUS
    (120) factor_a -> . NOT
    (121) factor_a -> . empty
    (135) empty -> .

    LP              shift and go to state 148
    MINUS           shift and go to state 150
    NOT             shift and go to state 151
    CTE_I           reduce using rule 135 (empty -> .)
    CTE_F           reduce using rule 135 (empty -> .)
    CTE_B           reduce using rule 135 (empty -> .)
    ID              reduce using rule 135 (empty -> .)

    expression                     shift and go to state 143
    comparison                     shift and go to state 144
    exp                            shift and go to state 145
    term                           shift and go to state 146
    factor                         shift and go to state 147
    factor_a                       shift and go to state 149
    empty                          shift and go to state 152

state 120

    (83) loop -> WHILE . expression block
    (96) expression -> . comparison expression_a
    (100) comparison -> . exp comparison_a
    (109) exp -> . term exp_a
    (113) term -> . factor term_a
    (117) factor -> . LP expression RP
    (118) factor -> . factor_a var_cte
    (119) factor_a -> . MINUS
    (120) factor_a -> . NOT
    (121) factor_a -> . empty
    (135) empty -> .

    LP              shift and go to state 148
    MINUS           shift and go to state 150
    NOT             shift and go to state 151
    CTE_I           reduce using rule 135 (empty -> .)
    CTE_F           reduce using rule 135 (empty -> .)
    CTE_B           reduce using rule 135 (empty -> .)
    ID              reduce using rule 135 (empty -> .)

    expression                     shift and go to state 153
    comparison                     shift and go to state 144
    exp                            shift and go to state 145
    term                           shift and go to state 146
    factor                         shift and go to state 147
    factor_a                       shift and go to state 149
    empty                          shift and go to state 152

state 121

    (75) return -> RETURN . expression SEMICOL
    (96) expression -> . comparison expression_a
    (100) comparison -> . exp comparison_a
    (109) exp -> . term exp_a
    (113) term -> . factor term_a
    (117) factor -> . LP expression RP
    (118) factor -> . factor_a var_cte
    (119) factor_a -> . MINUS
    (120) factor_a -> . NOT
    (121) factor_a -> . empty
    (135) empty -> .

    LP              shift and go to state 148
    MINUS           shift and go to state 150
    NOT             shift and go to state 151
    CTE_I           reduce using rule 135 (empty -> .)
    CTE_F           reduce using rule 135 (empty -> .)
    CTE_B           reduce using rule 135 (empty -> .)
    ID              reduce using rule 135 (empty -> .)

    expression                     shift and go to state 154
    comparison                     shift and go to state 144
    exp                            shift and go to state 145
    term                           shift and go to state 146
    factor                         shift and go to state 147
    factor_a                       shift and go to state 149
    empty                          shift and go to state 152

state 122

    (76) obj -> ID . array attribute
    (126) array -> . LC expression RC array_a
    (127) array -> . empty
    (135) empty -> .

    LC              shift and go to state 156
    DOT             reduce using rule 135 (empty -> .)
    IS              reduce using rule 135 (empty -> .)
    LP              reduce using rule 135 (empty -> .)
    RP              reduce using rule 135 (empty -> .)
    MUL             reduce using rule 135 (empty -> .)
    DIV             reduce using rule 135 (empty -> .)
    PLUS            reduce using rule 135 (empty -> .)
    MINUS           reduce using rule 135 (empty -> .)
    GEQ             reduce using rule 135 (empty -> .)
    LEQ             reduce using rule 135 (empty -> .)
    GT              reduce using rule 135 (empty -> .)
    LT              reduce using rule 135 (empty -> .)
    EQUAL           reduce using rule 135 (empty -> .)
    NEQ             reduce using rule 135 (empty -> .)
    AND             reduce using rule 135 (empty -> .)
    OR              reduce using rule 135 (empty -> .)
    LB              reduce using rule 135 (empty -> .)
    SEMICOL         reduce using rule 135 (empty -> .)
    COMMA           reduce using rule 135 (empty -> .)
    RC              reduce using rule 135 (empty -> .)

    array                          shift and go to state 155
    empty                          shift and go to state 157

state 123

    (50) function_block_a -> function_block_b function_block_a .

    PRINT           reduce using rule 50 (function_block_a -> function_block_b function_block_a .)
    INPUT           reduce using rule 50 (function_block_a -> function_block_b function_block_a .)
    IF              reduce using rule 50 (function_block_a -> function_block_b function_block_a .)
    WHILE           reduce using rule 50 (function_block_a -> function_block_b function_block_a .)
    RETURN          reduce using rule 50 (function_block_a -> function_block_b function_block_a .)
    ID              reduce using rule 50 (function_block_a -> function_block_b function_block_a .)
    RB              reduce using rule 50 (function_block_a -> function_block_b function_block_a .)


state 124

    (42) params -> ID COL type params_a .

    RP              reduce using rule 42 (params -> ID COL type params_a .)


state 125

    (44) params_a -> COMMA . params
    (42) params -> . ID COL type params_a
    (43) params -> . empty
    (135) empty -> .

    ID              shift and go to state 55
    RP              reduce using rule 135 (empty -> .)

    params                         shift and go to state 158
    empty                          shift and go to state 57

state 126

    (45) params_a -> empty .

    RP              reduce using rule 45 (params_a -> empty .)


state 127

    (39) function -> FUNCTION ID LP params RP function_a function_block .

    FUNCTION        reduce using rule 39 (function -> FUNCTION ID LP params RP function_a function_block .)
    MAIN            reduce using rule 39 (function -> FUNCTION ID LP params RP function_a function_block .)
    PRIVATE         reduce using rule 39 (function -> FUNCTION ID LP params RP function_a function_block .)
    RB              reduce using rule 39 (function -> FUNCTION ID LP params RP function_a function_block .)


state 128

    (40) function_a -> ARROW type .

    LB              reduce using rule 40 (function_a -> ARROW type .)


state 129

    (26) var -> VAR ID var1 COL type var2 var_a SEMICOL .

    VAR             reduce using rule 26 (var -> VAR ID var1 COL type var2 var_a SEMICOL .)
    FUNCTION        reduce using rule 26 (var -> VAR ID var1 COL type var2 var_a SEMICOL .)
    MAIN            reduce using rule 26 (var -> VAR ID var1 COL type var2 var_a SEMICOL .)
    PRIVATE         reduce using rule 26 (var -> VAR ID var1 COL type var2 var_a SEMICOL .)
    LET             reduce using rule 26 (var -> VAR ID var1 COL type var2 var_a SEMICOL .)
    INIT            reduce using rule 26 (var -> VAR ID var1 COL type var2 var_a SEMICOL .)
    PRINT           reduce using rule 26 (var -> VAR ID var1 COL type var2 var_a SEMICOL .)
    INPUT           reduce using rule 26 (var -> VAR ID var1 COL type var2 var_a SEMICOL .)
    IF              reduce using rule 26 (var -> VAR ID var1 COL type var2 var_a SEMICOL .)
    WHILE           reduce using rule 26 (var -> VAR ID var1 COL type var2 var_a SEMICOL .)
    RETURN          reduce using rule 26 (var -> VAR ID var1 COL type var2 var_a SEMICOL .)
    ID              reduce using rule 26 (var -> VAR ID var1 COL type var2 var_a SEMICOL .)
    RB              reduce using rule 26 (var -> VAR ID var1 COL type var2 var_a SEMICOL .)


state 130

    (28) var_a -> IS var_b . var3
    (36) var3 -> .

    SEMICOL         reduce using rule 36 (var3 -> .)

    var3                           shift and go to state 159

state 131

    (15) typeM -> LC CTE_I RC LC . CTE_I RC atomic type1

    CTE_I           shift and go to state 160


state 132

    (16) typeM -> LC CTE_I RC atomic . type2
    (19) type2 -> .

    SEMICOL         reduce using rule 19 (type2 -> .)

    type2                          shift and go to state 161

state 133

    (54) class -> CLASS ID class_a LB class_b init class_c class_d RB .

    LET             reduce using rule 54 (class -> CLASS ID class_a LB class_b init class_c class_d RB .)
    CLASS           reduce using rule 54 (class -> CLASS ID class_a LB class_b init class_c class_d RB .)
    VAR             reduce using rule 54 (class -> CLASS ID class_a LB class_b init class_c class_d RB .)
    FUNCTION        reduce using rule 54 (class -> CLASS ID class_a LB class_b init class_c class_d RB .)
    MAIN            reduce using rule 54 (class -> CLASS ID class_a LB class_b init class_c class_d RB .)


state 134

    (65) class_d -> class_e function . class_d
    (65) class_d -> . class_e function class_d
    (66) class_d -> . empty
    (59) class_e -> . PRIVATE
    (60) class_e -> . empty
    (135) empty -> .

    PRIVATE         shift and go to state 53
    RB              reduce using rule 135 (empty -> .)
    FUNCTION        reduce using rule 135 (empty -> .)

    class_e                        shift and go to state 103
    class_d                        shift and go to state 162
    empty                          shift and go to state 104

state 135

    (67) init -> INIT LP params RP . block
    (46) block -> . LB block_a RB

    LB              shift and go to state 164

    block                          shift and go to state 163

state 136

    (49) function_block -> LB function_block_a block_a RB .

    $end            reduce using rule 49 (function_block -> LB function_block_a block_a RB .)
    FUNCTION        reduce using rule 49 (function_block -> LB function_block_a block_a RB .)
    MAIN            reduce using rule 49 (function_block -> LB function_block_a block_a RB .)
    PRIVATE         reduce using rule 49 (function_block -> LB function_block_a block_a RB .)
    RB              reduce using rule 49 (function_block -> LB function_block_a block_a RB .)


state 137

    (47) block_a -> statement block_a .

    RB              reduce using rule 47 (block_a -> statement block_a .)


state 138

    (78) print -> PRINT LP . print_a RP SEMICOL
    (79) print_a -> . expression
    (80) print_a -> . CTE_S
    (81) print_a -> . empty
    (96) expression -> . comparison expression_a
    (135) empty -> .
    (100) comparison -> . exp comparison_a
    (109) exp -> . term exp_a
    (113) term -> . factor term_a
    (117) factor -> . LP expression RP
    (118) factor -> . factor_a var_cte
    (119) factor_a -> . MINUS
    (120) factor_a -> . NOT
    (121) factor_a -> . empty

    CTE_S           shift and go to state 167
    RP              reduce using rule 135 (empty -> .)
    CTE_I           reduce using rule 135 (empty -> .)
    CTE_F           reduce using rule 135 (empty -> .)
    CTE_B           reduce using rule 135 (empty -> .)
    ID              reduce using rule 135 (empty -> .)
    LP              shift and go to state 148
    MINUS           shift and go to state 150
    NOT             shift and go to state 151

    print_a                        shift and go to state 165
    expression                     shift and go to state 166
    empty                          shift and go to state 168
    comparison                     shift and go to state 144
    exp                            shift and go to state 145
    term                           shift and go to state 146
    factor                         shift and go to state 147
    factor_a                       shift and go to state 149

state 139

    (82) input -> INPUT LP . obj RP SEMICOL
    (76) obj -> . ID array attribute

    ID              shift and go to state 122

    obj                            shift and go to state 169

state 140

    (77) assignment -> obj IS . expression SEMICOL
    (96) expression -> . comparison expression_a
    (100) comparison -> . exp comparison_a
    (109) exp -> . term exp_a
    (113) term -> . factor term_a
    (117) factor -> . LP expression RP
    (118) factor -> . factor_a var_cte
    (119) factor_a -> . MINUS
    (120) factor_a -> . NOT
    (121) factor_a -> . empty
    (135) empty -> .

    LP              shift and go to state 148
    MINUS           shift and go to state 150
    NOT             shift and go to state 151
    CTE_I           reduce using rule 135 (empty -> .)
    CTE_F           reduce using rule 135 (empty -> .)
    CTE_B           reduce using rule 135 (empty -> .)
    ID              reduce using rule 135 (empty -> .)

    expression                     shift and go to state 170
    comparison                     shift and go to state 144
    exp                            shift and go to state 145
    term                           shift and go to state 146
    factor                         shift and go to state 147
    factor_a                       shift and go to state 149
    empty                          shift and go to state 152

state 141

    (84) call_function -> obj call_func . SEMICOL

    SEMICOL         shift and go to state 171


state 142

    (132) call_func -> LP . call_params RP
    (85) call_params -> . expression call_params_a
    (86) call_params -> . empty
    (96) expression -> . comparison expression_a
    (135) empty -> .
    (100) comparison -> . exp comparison_a
    (109) exp -> . term exp_a
    (113) term -> . factor term_a
    (117) factor -> . LP expression RP
    (118) factor -> . factor_a var_cte
    (119) factor_a -> . MINUS
    (120) factor_a -> . NOT
    (121) factor_a -> . empty

    RP              reduce using rule 135 (empty -> .)
    CTE_I           reduce using rule 135 (empty -> .)
    CTE_F           reduce using rule 135 (empty -> .)
    CTE_B           reduce using rule 135 (empty -> .)
    ID              reduce using rule 135 (empty -> .)
    LP              shift and go to state 148
    MINUS           shift and go to state 150
    NOT             shift and go to state 151

    call_params                    shift and go to state 172
    expression                     shift and go to state 173
    empty                          shift and go to state 174
    comparison                     shift and go to state 144
    exp                            shift and go to state 145
    term                           shift and go to state 146
    factor                         shift and go to state 147
    factor_a                       shift and go to state 149

state 143

    (89) condition -> IF expression . block condition_a condition_b
    (46) block -> . LB block_a RB

    LB              shift and go to state 164

    block                          shift and go to state 175

state 144

    (96) expression -> comparison . expression_a
    (97) expression_a -> . AND comparison expression_a
    (98) expression_a -> . OR comparison
    (99) expression_a -> . empty
    (135) empty -> .

    AND             shift and go to state 177
    OR              shift and go to state 178
    LB              reduce using rule 135 (empty -> .)
    SEMICOL         reduce using rule 135 (empty -> .)
    RP              reduce using rule 135 (empty -> .)
    COMMA           reduce using rule 135 (empty -> .)
    RC              reduce using rule 135 (empty -> .)

    expression_a                   shift and go to state 176
    empty                          shift and go to state 179

state 145

    (100) comparison -> exp . comparison_a
    (101) comparison_a -> . comparison_b exp comparison_a
    (102) comparison_a -> . empty
    (103) comparison_b -> . GEQ
    (104) comparison_b -> . LEQ
    (105) comparison_b -> . GT
    (106) comparison_b -> . LT
    (107) comparison_b -> . EQUAL
    (108) comparison_b -> . NEQ
    (135) empty -> .

    GEQ             shift and go to state 183
    LEQ             shift and go to state 184
    GT              shift and go to state 185
    LT              shift and go to state 186
    EQUAL           shift and go to state 187
    NEQ             shift and go to state 188
    AND             reduce using rule 135 (empty -> .)
    OR              reduce using rule 135 (empty -> .)
    LB              reduce using rule 135 (empty -> .)
    SEMICOL         reduce using rule 135 (empty -> .)
    RP              reduce using rule 135 (empty -> .)
    COMMA           reduce using rule 135 (empty -> .)
    RC              reduce using rule 135 (empty -> .)

    comparison_a                   shift and go to state 180
    comparison_b                   shift and go to state 181
    empty                          shift and go to state 182

state 146

    (109) exp -> term . exp_a
    (110) exp_a -> . PLUS term exp_a
    (111) exp_a -> . MINUS term exp_a
    (112) exp_a -> . empty
    (135) empty -> .

    PLUS            shift and go to state 190
    MINUS           shift and go to state 191
    GEQ             reduce using rule 135 (empty -> .)
    LEQ             reduce using rule 135 (empty -> .)
    GT              reduce using rule 135 (empty -> .)
    LT              reduce using rule 135 (empty -> .)
    EQUAL           reduce using rule 135 (empty -> .)
    NEQ             reduce using rule 135 (empty -> .)
    AND             reduce using rule 135 (empty -> .)
    OR              reduce using rule 135 (empty -> .)
    LB              reduce using rule 135 (empty -> .)
    SEMICOL         reduce using rule 135 (empty -> .)
    RP              reduce using rule 135 (empty -> .)
    COMMA           reduce using rule 135 (empty -> .)
    RC              reduce using rule 135 (empty -> .)

    exp_a                          shift and go to state 189
    empty                          shift and go to state 192

state 147

    (113) term -> factor . term_a
    (114) term_a -> . MUL factor term_a
    (115) term_a -> . DIV factor term_a
    (116) term_a -> . empty
    (135) empty -> .

    MUL             shift and go to state 194
    DIV             shift and go to state 195
    PLUS            reduce using rule 135 (empty -> .)
    MINUS           reduce using rule 135 (empty -> .)
    GEQ             reduce using rule 135 (empty -> .)
    LEQ             reduce using rule 135 (empty -> .)
    GT              reduce using rule 135 (empty -> .)
    LT              reduce using rule 135 (empty -> .)
    EQUAL           reduce using rule 135 (empty -> .)
    NEQ             reduce using rule 135 (empty -> .)
    AND             reduce using rule 135 (empty -> .)
    OR              reduce using rule 135 (empty -> .)
    LB              reduce using rule 135 (empty -> .)
    SEMICOL         reduce using rule 135 (empty -> .)
    RP              reduce using rule 135 (empty -> .)
    COMMA           reduce using rule 135 (empty -> .)
    RC              reduce using rule 135 (empty -> .)

    term_a                         shift and go to state 193
    empty                          shift and go to state 196

state 148

    (117) factor -> LP . expression RP
    (96) expression -> . comparison expression_a
    (100) comparison -> . exp comparison_a
    (109) exp -> . term exp_a
    (113) term -> . factor term_a
    (117) factor -> . LP expression RP
    (118) factor -> . factor_a var_cte
    (119) factor_a -> . MINUS
    (120) factor_a -> . NOT
    (121) factor_a -> . empty
    (135) empty -> .

    LP              shift and go to state 148
    MINUS           shift and go to state 150
    NOT             shift and go to state 151
    CTE_I           reduce using rule 135 (empty -> .)
    CTE_F           reduce using rule 135 (empty -> .)
    CTE_B           reduce using rule 135 (empty -> .)
    ID              reduce using rule 135 (empty -> .)

    expression                     shift and go to state 197
    comparison                     shift and go to state 144
    exp                            shift and go to state 145
    term                           shift and go to state 146
    factor                         shift and go to state 147
    factor_a                       shift and go to state 149
    empty                          shift and go to state 152

state 149

    (118) factor -> factor_a . var_cte
    (122) var_cte -> . obj call_func_optional
    (123) var_cte -> . CTE_I
    (124) var_cte -> . CTE_F
    (125) var_cte -> . CTE_B
    (76) obj -> . ID array attribute

    CTE_I           shift and go to state 200
    CTE_F           shift and go to state 201
    CTE_B           shift and go to state 202
    ID              shift and go to state 122

    var_cte                        shift and go to state 198
    obj                            shift and go to state 199

state 150

    (119) factor_a -> MINUS .

    CTE_I           reduce using rule 119 (factor_a -> MINUS .)
    CTE_F           reduce using rule 119 (factor_a -> MINUS .)
    CTE_B           reduce using rule 119 (factor_a -> MINUS .)
    ID              reduce using rule 119 (factor_a -> MINUS .)


state 151

    (120) factor_a -> NOT .

    CTE_I           reduce using rule 120 (factor_a -> NOT .)
    CTE_F           reduce using rule 120 (factor_a -> NOT .)
    CTE_B           reduce using rule 120 (factor_a -> NOT .)
    ID              reduce using rule 120 (factor_a -> NOT .)


state 152

    (121) factor_a -> empty .

    CTE_I           reduce using rule 121 (factor_a -> empty .)
    CTE_F           reduce using rule 121 (factor_a -> empty .)
    CTE_B           reduce using rule 121 (factor_a -> empty .)
    ID              reduce using rule 121 (factor_a -> empty .)


state 153

    (83) loop -> WHILE expression . block
    (46) block -> . LB block_a RB

    LB              shift and go to state 164

    block                          shift and go to state 203

state 154

    (75) return -> RETURN expression . SEMICOL

    SEMICOL         shift and go to state 204


state 155

    (76) obj -> ID array . attribute
    (130) attribute -> . DOT ID
    (131) attribute -> . empty
    (135) empty -> .

    DOT             shift and go to state 206
    IS              reduce using rule 135 (empty -> .)
    LP              reduce using rule 135 (empty -> .)
    RP              reduce using rule 135 (empty -> .)
    MUL             reduce using rule 135 (empty -> .)
    DIV             reduce using rule 135 (empty -> .)
    PLUS            reduce using rule 135 (empty -> .)
    MINUS           reduce using rule 135 (empty -> .)
    GEQ             reduce using rule 135 (empty -> .)
    LEQ             reduce using rule 135 (empty -> .)
    GT              reduce using rule 135 (empty -> .)
    LT              reduce using rule 135 (empty -> .)
    EQUAL           reduce using rule 135 (empty -> .)
    NEQ             reduce using rule 135 (empty -> .)
    AND             reduce using rule 135 (empty -> .)
    OR              reduce using rule 135 (empty -> .)
    LB              reduce using rule 135 (empty -> .)
    SEMICOL         reduce using rule 135 (empty -> .)
    COMMA           reduce using rule 135 (empty -> .)
    RC              reduce using rule 135 (empty -> .)

    attribute                      shift and go to state 205
    empty                          shift and go to state 207

state 156

    (126) array -> LC . expression RC array_a
    (96) expression -> . comparison expression_a
    (100) comparison -> . exp comparison_a
    (109) exp -> . term exp_a
    (113) term -> . factor term_a
    (117) factor -> . LP expression RP
    (118) factor -> . factor_a var_cte
    (119) factor_a -> . MINUS
    (120) factor_a -> . NOT
    (121) factor_a -> . empty
    (135) empty -> .

    LP              shift and go to state 148
    MINUS           shift and go to state 150
    NOT             shift and go to state 151
    CTE_I           reduce using rule 135 (empty -> .)
    CTE_F           reduce using rule 135 (empty -> .)
    CTE_B           reduce using rule 135 (empty -> .)
    ID              reduce using rule 135 (empty -> .)

    expression                     shift and go to state 208
    comparison                     shift and go to state 144
    exp                            shift and go to state 145
    term                           shift and go to state 146
    factor                         shift and go to state 147
    factor_a                       shift and go to state 149
    empty                          shift and go to state 152

state 157

    (127) array -> empty .

    DOT             reduce using rule 127 (array -> empty .)
    IS              reduce using rule 127 (array -> empty .)
    LP              reduce using rule 127 (array -> empty .)
    RP              reduce using rule 127 (array -> empty .)
    MUL             reduce using rule 127 (array -> empty .)
    DIV             reduce using rule 127 (array -> empty .)
    PLUS            reduce using rule 127 (array -> empty .)
    MINUS           reduce using rule 127 (array -> empty .)
    GEQ             reduce using rule 127 (array -> empty .)
    LEQ             reduce using rule 127 (array -> empty .)
    GT              reduce using rule 127 (array -> empty .)
    LT              reduce using rule 127 (array -> empty .)
    EQUAL           reduce using rule 127 (array -> empty .)
    NEQ             reduce using rule 127 (array -> empty .)
    AND             reduce using rule 127 (array -> empty .)
    OR              reduce using rule 127 (array -> empty .)
    LB              reduce using rule 127 (array -> empty .)
    SEMICOL         reduce using rule 127 (array -> empty .)
    COMMA           reduce using rule 127 (array -> empty .)
    RC              reduce using rule 127 (array -> empty .)


state 158

    (44) params_a -> COMMA params .

    RP              reduce using rule 44 (params_a -> COMMA params .)


state 159

    (28) var_a -> IS var_b var3 .

    SEMICOL         reduce using rule 28 (var_a -> IS var_b var3 .)


state 160

    (15) typeM -> LC CTE_I RC LC CTE_I . RC atomic type1

    RC              shift and go to state 209


state 161

    (16) typeM -> LC CTE_I RC atomic type2 .

    SEMICOL         reduce using rule 16 (typeM -> LC CTE_I RC atomic type2 .)


state 162

    (65) class_d -> class_e function class_d .

    RB              reduce using rule 65 (class_d -> class_e function class_d .)


state 163

    (67) init -> INIT LP params RP block .

    INIT            reduce using rule 67 (init -> INIT LP params RP block .)
    PRIVATE         reduce using rule 67 (init -> INIT LP params RP block .)
    RB              reduce using rule 67 (init -> INIT LP params RP block .)
    FUNCTION        reduce using rule 67 (init -> INIT LP params RP block .)


state 164

    (46) block -> LB . block_a RB
    (47) block_a -> . statement block_a
    (48) block_a -> . empty
    (68) statement -> . print
    (69) statement -> . input
    (70) statement -> . assignment
    (71) statement -> . condition
    (72) statement -> . loop
    (73) statement -> . call_function
    (74) statement -> . return
    (135) empty -> .
    (78) print -> . PRINT LP print_a RP SEMICOL
    (82) input -> . INPUT LP obj RP SEMICOL
    (77) assignment -> . obj IS expression SEMICOL
    (89) condition -> . IF expression block condition_a condition_b
    (83) loop -> . WHILE expression block
    (84) call_function -> . obj call_func SEMICOL
    (75) return -> . RETURN expression SEMICOL
    (76) obj -> . ID array attribute

    RB              reduce using rule 135 (empty -> .)
    PRINT           shift and go to state 116
    INPUT           shift and go to state 117
    IF              shift and go to state 119
    WHILE           shift and go to state 120
    RETURN          shift and go to state 121
    ID              shift and go to state 122

    block_a                        shift and go to state 210
    statement                      shift and go to state 107
    empty                          shift and go to state 108
    print                          shift and go to state 109
    input                          shift and go to state 110
    assignment                     shift and go to state 111
    condition                      shift and go to state 112
    loop                           shift and go to state 113
    call_function                  shift and go to state 114
    return                         shift and go to state 115
    obj                            shift and go to state 118

state 165

    (78) print -> PRINT LP print_a . RP SEMICOL

    RP              shift and go to state 211


state 166

    (79) print_a -> expression .

    RP              reduce using rule 79 (print_a -> expression .)


state 167

    (80) print_a -> CTE_S .

    RP              reduce using rule 80 (print_a -> CTE_S .)


state 168

    (81) print_a -> empty .
    (121) factor_a -> empty .

    RP              reduce using rule 81 (print_a -> empty .)
    CTE_I           reduce using rule 121 (factor_a -> empty .)
    CTE_F           reduce using rule 121 (factor_a -> empty .)
    CTE_B           reduce using rule 121 (factor_a -> empty .)
    ID              reduce using rule 121 (factor_a -> empty .)


state 169

    (82) input -> INPUT LP obj . RP SEMICOL

    RP              shift and go to state 212


state 170

    (77) assignment -> obj IS expression . SEMICOL

    SEMICOL         shift and go to state 213


state 171

    (84) call_function -> obj call_func SEMICOL .

    PRINT           reduce using rule 84 (call_function -> obj call_func SEMICOL .)
    INPUT           reduce using rule 84 (call_function -> obj call_func SEMICOL .)
    IF              reduce using rule 84 (call_function -> obj call_func SEMICOL .)
    WHILE           reduce using rule 84 (call_function -> obj call_func SEMICOL .)
    RETURN          reduce using rule 84 (call_function -> obj call_func SEMICOL .)
    ID              reduce using rule 84 (call_function -> obj call_func SEMICOL .)
    RB              reduce using rule 84 (call_function -> obj call_func SEMICOL .)


state 172

    (132) call_func -> LP call_params . RP

    RP              shift and go to state 214


state 173

    (85) call_params -> expression . call_params_a
    (87) call_params_a -> . COMMA expression call_params_a
    (88) call_params_a -> . empty
    (135) empty -> .

    COMMA           shift and go to state 216
    RP              reduce using rule 135 (empty -> .)

    call_params_a                  shift and go to state 215
    empty                          shift and go to state 217

state 174

    (86) call_params -> empty .
    (121) factor_a -> empty .

    RP              reduce using rule 86 (call_params -> empty .)
    CTE_I           reduce using rule 121 (factor_a -> empty .)
    CTE_F           reduce using rule 121 (factor_a -> empty .)
    CTE_B           reduce using rule 121 (factor_a -> empty .)
    ID              reduce using rule 121 (factor_a -> empty .)


state 175

    (89) condition -> IF expression block . condition_a condition_b
    (90) condition_a -> . elseif condition_a
    (91) condition_a -> . empty
    (94) elseif -> . ELSEIF expression block
    (135) empty -> .

    ELSEIF          shift and go to state 221
    ELSE            reduce using rule 135 (empty -> .)
    PRINT           reduce using rule 135 (empty -> .)
    INPUT           reduce using rule 135 (empty -> .)
    IF              reduce using rule 135 (empty -> .)
    WHILE           reduce using rule 135 (empty -> .)
    RETURN          reduce using rule 135 (empty -> .)
    ID              reduce using rule 135 (empty -> .)
    RB              reduce using rule 135 (empty -> .)

    condition_a                    shift and go to state 218
    elseif                         shift and go to state 219
    empty                          shift and go to state 220

state 176

    (96) expression -> comparison expression_a .

    LB              reduce using rule 96 (expression -> comparison expression_a .)
    SEMICOL         reduce using rule 96 (expression -> comparison expression_a .)
    RP              reduce using rule 96 (expression -> comparison expression_a .)
    COMMA           reduce using rule 96 (expression -> comparison expression_a .)
    RC              reduce using rule 96 (expression -> comparison expression_a .)


state 177

    (97) expression_a -> AND . comparison expression_a
    (100) comparison -> . exp comparison_a
    (109) exp -> . term exp_a
    (113) term -> . factor term_a
    (117) factor -> . LP expression RP
    (118) factor -> . factor_a var_cte
    (119) factor_a -> . MINUS
    (120) factor_a -> . NOT
    (121) factor_a -> . empty
    (135) empty -> .

    LP              shift and go to state 148
    MINUS           shift and go to state 150
    NOT             shift and go to state 151
    CTE_I           reduce using rule 135 (empty -> .)
    CTE_F           reduce using rule 135 (empty -> .)
    CTE_B           reduce using rule 135 (empty -> .)
    ID              reduce using rule 135 (empty -> .)

    comparison                     shift and go to state 222
    exp                            shift and go to state 145
    term                           shift and go to state 146
    factor                         shift and go to state 147
    factor_a                       shift and go to state 149
    empty                          shift and go to state 152

state 178

    (98) expression_a -> OR . comparison
    (100) comparison -> . exp comparison_a
    (109) exp -> . term exp_a
    (113) term -> . factor term_a
    (117) factor -> . LP expression RP
    (118) factor -> . factor_a var_cte
    (119) factor_a -> . MINUS
    (120) factor_a -> . NOT
    (121) factor_a -> . empty
    (135) empty -> .

    LP              shift and go to state 148
    MINUS           shift and go to state 150
    NOT             shift and go to state 151
    CTE_I           reduce using rule 135 (empty -> .)
    CTE_F           reduce using rule 135 (empty -> .)
    CTE_B           reduce using rule 135 (empty -> .)
    ID              reduce using rule 135 (empty -> .)

    comparison                     shift and go to state 223
    exp                            shift and go to state 145
    term                           shift and go to state 146
    factor                         shift and go to state 147
    factor_a                       shift and go to state 149
    empty                          shift and go to state 152

state 179

    (99) expression_a -> empty .

    LB              reduce using rule 99 (expression_a -> empty .)
    SEMICOL         reduce using rule 99 (expression_a -> empty .)
    RP              reduce using rule 99 (expression_a -> empty .)
    COMMA           reduce using rule 99 (expression_a -> empty .)
    RC              reduce using rule 99 (expression_a -> empty .)


state 180

    (100) comparison -> exp comparison_a .

    AND             reduce using rule 100 (comparison -> exp comparison_a .)
    OR              reduce using rule 100 (comparison -> exp comparison_a .)
    LB              reduce using rule 100 (comparison -> exp comparison_a .)
    SEMICOL         reduce using rule 100 (comparison -> exp comparison_a .)
    RP              reduce using rule 100 (comparison -> exp comparison_a .)
    COMMA           reduce using rule 100 (comparison -> exp comparison_a .)
    RC              reduce using rule 100 (comparison -> exp comparison_a .)


state 181

    (101) comparison_a -> comparison_b . exp comparison_a
    (109) exp -> . term exp_a
    (113) term -> . factor term_a
    (117) factor -> . LP expression RP
    (118) factor -> . factor_a var_cte
    (119) factor_a -> . MINUS
    (120) factor_a -> . NOT
    (121) factor_a -> . empty
    (135) empty -> .

    LP              shift and go to state 148
    MINUS           shift and go to state 150
    NOT             shift and go to state 151
    CTE_I           reduce using rule 135 (empty -> .)
    CTE_F           reduce using rule 135 (empty -> .)
    CTE_B           reduce using rule 135 (empty -> .)
    ID              reduce using rule 135 (empty -> .)

    exp                            shift and go to state 224
    term                           shift and go to state 146
    factor                         shift and go to state 147
    factor_a                       shift and go to state 149
    empty                          shift and go to state 152

state 182

    (102) comparison_a -> empty .

    AND             reduce using rule 102 (comparison_a -> empty .)
    OR              reduce using rule 102 (comparison_a -> empty .)
    LB              reduce using rule 102 (comparison_a -> empty .)
    SEMICOL         reduce using rule 102 (comparison_a -> empty .)
    RP              reduce using rule 102 (comparison_a -> empty .)
    COMMA           reduce using rule 102 (comparison_a -> empty .)
    RC              reduce using rule 102 (comparison_a -> empty .)


state 183

    (103) comparison_b -> GEQ .

    LP              reduce using rule 103 (comparison_b -> GEQ .)
    MINUS           reduce using rule 103 (comparison_b -> GEQ .)
    NOT             reduce using rule 103 (comparison_b -> GEQ .)
    CTE_I           reduce using rule 103 (comparison_b -> GEQ .)
    CTE_F           reduce using rule 103 (comparison_b -> GEQ .)
    CTE_B           reduce using rule 103 (comparison_b -> GEQ .)
    ID              reduce using rule 103 (comparison_b -> GEQ .)


state 184

    (104) comparison_b -> LEQ .

    LP              reduce using rule 104 (comparison_b -> LEQ .)
    MINUS           reduce using rule 104 (comparison_b -> LEQ .)
    NOT             reduce using rule 104 (comparison_b -> LEQ .)
    CTE_I           reduce using rule 104 (comparison_b -> LEQ .)
    CTE_F           reduce using rule 104 (comparison_b -> LEQ .)
    CTE_B           reduce using rule 104 (comparison_b -> LEQ .)
    ID              reduce using rule 104 (comparison_b -> LEQ .)


state 185

    (105) comparison_b -> GT .

    LP              reduce using rule 105 (comparison_b -> GT .)
    MINUS           reduce using rule 105 (comparison_b -> GT .)
    NOT             reduce using rule 105 (comparison_b -> GT .)
    CTE_I           reduce using rule 105 (comparison_b -> GT .)
    CTE_F           reduce using rule 105 (comparison_b -> GT .)
    CTE_B           reduce using rule 105 (comparison_b -> GT .)
    ID              reduce using rule 105 (comparison_b -> GT .)


state 186

    (106) comparison_b -> LT .

    LP              reduce using rule 106 (comparison_b -> LT .)
    MINUS           reduce using rule 106 (comparison_b -> LT .)
    NOT             reduce using rule 106 (comparison_b -> LT .)
    CTE_I           reduce using rule 106 (comparison_b -> LT .)
    CTE_F           reduce using rule 106 (comparison_b -> LT .)
    CTE_B           reduce using rule 106 (comparison_b -> LT .)
    ID              reduce using rule 106 (comparison_b -> LT .)


state 187

    (107) comparison_b -> EQUAL .

    LP              reduce using rule 107 (comparison_b -> EQUAL .)
    MINUS           reduce using rule 107 (comparison_b -> EQUAL .)
    NOT             reduce using rule 107 (comparison_b -> EQUAL .)
    CTE_I           reduce using rule 107 (comparison_b -> EQUAL .)
    CTE_F           reduce using rule 107 (comparison_b -> EQUAL .)
    CTE_B           reduce using rule 107 (comparison_b -> EQUAL .)
    ID              reduce using rule 107 (comparison_b -> EQUAL .)


state 188

    (108) comparison_b -> NEQ .

    LP              reduce using rule 108 (comparison_b -> NEQ .)
    MINUS           reduce using rule 108 (comparison_b -> NEQ .)
    NOT             reduce using rule 108 (comparison_b -> NEQ .)
    CTE_I           reduce using rule 108 (comparison_b -> NEQ .)
    CTE_F           reduce using rule 108 (comparison_b -> NEQ .)
    CTE_B           reduce using rule 108 (comparison_b -> NEQ .)
    ID              reduce using rule 108 (comparison_b -> NEQ .)


state 189

    (109) exp -> term exp_a .

    GEQ             reduce using rule 109 (exp -> term exp_a .)
    LEQ             reduce using rule 109 (exp -> term exp_a .)
    GT              reduce using rule 109 (exp -> term exp_a .)
    LT              reduce using rule 109 (exp -> term exp_a .)
    EQUAL           reduce using rule 109 (exp -> term exp_a .)
    NEQ             reduce using rule 109 (exp -> term exp_a .)
    AND             reduce using rule 109 (exp -> term exp_a .)
    OR              reduce using rule 109 (exp -> term exp_a .)
    LB              reduce using rule 109 (exp -> term exp_a .)
    SEMICOL         reduce using rule 109 (exp -> term exp_a .)
    RP              reduce using rule 109 (exp -> term exp_a .)
    COMMA           reduce using rule 109 (exp -> term exp_a .)
    RC              reduce using rule 109 (exp -> term exp_a .)


state 190

    (110) exp_a -> PLUS . term exp_a
    (113) term -> . factor term_a
    (117) factor -> . LP expression RP
    (118) factor -> . factor_a var_cte
    (119) factor_a -> . MINUS
    (120) factor_a -> . NOT
    (121) factor_a -> . empty
    (135) empty -> .

    LP              shift and go to state 148
    MINUS           shift and go to state 150
    NOT             shift and go to state 151
    CTE_I           reduce using rule 135 (empty -> .)
    CTE_F           reduce using rule 135 (empty -> .)
    CTE_B           reduce using rule 135 (empty -> .)
    ID              reduce using rule 135 (empty -> .)

    term                           shift and go to state 225
    factor                         shift and go to state 147
    factor_a                       shift and go to state 149
    empty                          shift and go to state 152

state 191

    (111) exp_a -> MINUS . term exp_a
    (113) term -> . factor term_a
    (117) factor -> . LP expression RP
    (118) factor -> . factor_a var_cte
    (119) factor_a -> . MINUS
    (120) factor_a -> . NOT
    (121) factor_a -> . empty
    (135) empty -> .

    LP              shift and go to state 148
    MINUS           shift and go to state 150
    NOT             shift and go to state 151
    CTE_I           reduce using rule 135 (empty -> .)
    CTE_F           reduce using rule 135 (empty -> .)
    CTE_B           reduce using rule 135 (empty -> .)
    ID              reduce using rule 135 (empty -> .)

    term                           shift and go to state 226
    factor                         shift and go to state 147
    factor_a                       shift and go to state 149
    empty                          shift and go to state 152

state 192

    (112) exp_a -> empty .

    GEQ             reduce using rule 112 (exp_a -> empty .)
    LEQ             reduce using rule 112 (exp_a -> empty .)
    GT              reduce using rule 112 (exp_a -> empty .)
    LT              reduce using rule 112 (exp_a -> empty .)
    EQUAL           reduce using rule 112 (exp_a -> empty .)
    NEQ             reduce using rule 112 (exp_a -> empty .)
    AND             reduce using rule 112 (exp_a -> empty .)
    OR              reduce using rule 112 (exp_a -> empty .)
    LB              reduce using rule 112 (exp_a -> empty .)
    SEMICOL         reduce using rule 112 (exp_a -> empty .)
    RP              reduce using rule 112 (exp_a -> empty .)
    COMMA           reduce using rule 112 (exp_a -> empty .)
    RC              reduce using rule 112 (exp_a -> empty .)


state 193

    (113) term -> factor term_a .

    PLUS            reduce using rule 113 (term -> factor term_a .)
    MINUS           reduce using rule 113 (term -> factor term_a .)
    GEQ             reduce using rule 113 (term -> factor term_a .)
    LEQ             reduce using rule 113 (term -> factor term_a .)
    GT              reduce using rule 113 (term -> factor term_a .)
    LT              reduce using rule 113 (term -> factor term_a .)
    EQUAL           reduce using rule 113 (term -> factor term_a .)
    NEQ             reduce using rule 113 (term -> factor term_a .)
    AND             reduce using rule 113 (term -> factor term_a .)
    OR              reduce using rule 113 (term -> factor term_a .)
    LB              reduce using rule 113 (term -> factor term_a .)
    SEMICOL         reduce using rule 113 (term -> factor term_a .)
    RP              reduce using rule 113 (term -> factor term_a .)
    COMMA           reduce using rule 113 (term -> factor term_a .)
    RC              reduce using rule 113 (term -> factor term_a .)


state 194

    (114) term_a -> MUL . factor term_a
    (117) factor -> . LP expression RP
    (118) factor -> . factor_a var_cte
    (119) factor_a -> . MINUS
    (120) factor_a -> . NOT
    (121) factor_a -> . empty
    (135) empty -> .

    LP              shift and go to state 148
    MINUS           shift and go to state 150
    NOT             shift and go to state 151
    CTE_I           reduce using rule 135 (empty -> .)
    CTE_F           reduce using rule 135 (empty -> .)
    CTE_B           reduce using rule 135 (empty -> .)
    ID              reduce using rule 135 (empty -> .)

    factor                         shift and go to state 227
    factor_a                       shift and go to state 149
    empty                          shift and go to state 152

state 195

    (115) term_a -> DIV . factor term_a
    (117) factor -> . LP expression RP
    (118) factor -> . factor_a var_cte
    (119) factor_a -> . MINUS
    (120) factor_a -> . NOT
    (121) factor_a -> . empty
    (135) empty -> .

    LP              shift and go to state 148
    MINUS           shift and go to state 150
    NOT             shift and go to state 151
    CTE_I           reduce using rule 135 (empty -> .)
    CTE_F           reduce using rule 135 (empty -> .)
    CTE_B           reduce using rule 135 (empty -> .)
    ID              reduce using rule 135 (empty -> .)

    factor                         shift and go to state 228
    factor_a                       shift and go to state 149
    empty                          shift and go to state 152

state 196

    (116) term_a -> empty .

    PLUS            reduce using rule 116 (term_a -> empty .)
    MINUS           reduce using rule 116 (term_a -> empty .)
    GEQ             reduce using rule 116 (term_a -> empty .)
    LEQ             reduce using rule 116 (term_a -> empty .)
    GT              reduce using rule 116 (term_a -> empty .)
    LT              reduce using rule 116 (term_a -> empty .)
    EQUAL           reduce using rule 116 (term_a -> empty .)
    NEQ             reduce using rule 116 (term_a -> empty .)
    AND             reduce using rule 116 (term_a -> empty .)
    OR              reduce using rule 116 (term_a -> empty .)
    LB              reduce using rule 116 (term_a -> empty .)
    SEMICOL         reduce using rule 116 (term_a -> empty .)
    RP              reduce using rule 116 (term_a -> empty .)
    COMMA           reduce using rule 116 (term_a -> empty .)
    RC              reduce using rule 116 (term_a -> empty .)


state 197

    (117) factor -> LP expression . RP

    RP              shift and go to state 229


state 198

    (118) factor -> factor_a var_cte .

    MUL             reduce using rule 118 (factor -> factor_a var_cte .)
    DIV             reduce using rule 118 (factor -> factor_a var_cte .)
    PLUS            reduce using rule 118 (factor -> factor_a var_cte .)
    MINUS           reduce using rule 118 (factor -> factor_a var_cte .)
    GEQ             reduce using rule 118 (factor -> factor_a var_cte .)
    LEQ             reduce using rule 118 (factor -> factor_a var_cte .)
    GT              reduce using rule 118 (factor -> factor_a var_cte .)
    LT              reduce using rule 118 (factor -> factor_a var_cte .)
    EQUAL           reduce using rule 118 (factor -> factor_a var_cte .)
    NEQ             reduce using rule 118 (factor -> factor_a var_cte .)
    AND             reduce using rule 118 (factor -> factor_a var_cte .)
    OR              reduce using rule 118 (factor -> factor_a var_cte .)
    LB              reduce using rule 118 (factor -> factor_a var_cte .)
    SEMICOL         reduce using rule 118 (factor -> factor_a var_cte .)
    RP              reduce using rule 118 (factor -> factor_a var_cte .)
    COMMA           reduce using rule 118 (factor -> factor_a var_cte .)
    RC              reduce using rule 118 (factor -> factor_a var_cte .)


state 199

    (122) var_cte -> obj . call_func_optional
    (133) call_func_optional -> . call_func
    (134) call_func_optional -> . empty
    (132) call_func -> . LP call_params RP
    (135) empty -> .

    LP              shift and go to state 142
    MUL             reduce using rule 135 (empty -> .)
    DIV             reduce using rule 135 (empty -> .)
    PLUS            reduce using rule 135 (empty -> .)
    MINUS           reduce using rule 135 (empty -> .)
    GEQ             reduce using rule 135 (empty -> .)
    LEQ             reduce using rule 135 (empty -> .)
    GT              reduce using rule 135 (empty -> .)
    LT              reduce using rule 135 (empty -> .)
    EQUAL           reduce using rule 135 (empty -> .)
    NEQ             reduce using rule 135 (empty -> .)
    AND             reduce using rule 135 (empty -> .)
    OR              reduce using rule 135 (empty -> .)
    LB              reduce using rule 135 (empty -> .)
    SEMICOL         reduce using rule 135 (empty -> .)
    RP              reduce using rule 135 (empty -> .)
    COMMA           reduce using rule 135 (empty -> .)
    RC              reduce using rule 135 (empty -> .)

    call_func_optional             shift and go to state 230
    call_func                      shift and go to state 231
    empty                          shift and go to state 232

state 200

    (123) var_cte -> CTE_I .

    MUL             reduce using rule 123 (var_cte -> CTE_I .)
    DIV             reduce using rule 123 (var_cte -> CTE_I .)
    PLUS            reduce using rule 123 (var_cte -> CTE_I .)
    MINUS           reduce using rule 123 (var_cte -> CTE_I .)
    GEQ             reduce using rule 123 (var_cte -> CTE_I .)
    LEQ             reduce using rule 123 (var_cte -> CTE_I .)
    GT              reduce using rule 123 (var_cte -> CTE_I .)
    LT              reduce using rule 123 (var_cte -> CTE_I .)
    EQUAL           reduce using rule 123 (var_cte -> CTE_I .)
    NEQ             reduce using rule 123 (var_cte -> CTE_I .)
    AND             reduce using rule 123 (var_cte -> CTE_I .)
    OR              reduce using rule 123 (var_cte -> CTE_I .)
    LB              reduce using rule 123 (var_cte -> CTE_I .)
    SEMICOL         reduce using rule 123 (var_cte -> CTE_I .)
    RP              reduce using rule 123 (var_cte -> CTE_I .)
    COMMA           reduce using rule 123 (var_cte -> CTE_I .)
    RC              reduce using rule 123 (var_cte -> CTE_I .)


state 201

    (124) var_cte -> CTE_F .

    MUL             reduce using rule 124 (var_cte -> CTE_F .)
    DIV             reduce using rule 124 (var_cte -> CTE_F .)
    PLUS            reduce using rule 124 (var_cte -> CTE_F .)
    MINUS           reduce using rule 124 (var_cte -> CTE_F .)
    GEQ             reduce using rule 124 (var_cte -> CTE_F .)
    LEQ             reduce using rule 124 (var_cte -> CTE_F .)
    GT              reduce using rule 124 (var_cte -> CTE_F .)
    LT              reduce using rule 124 (var_cte -> CTE_F .)
    EQUAL           reduce using rule 124 (var_cte -> CTE_F .)
    NEQ             reduce using rule 124 (var_cte -> CTE_F .)
    AND             reduce using rule 124 (var_cte -> CTE_F .)
    OR              reduce using rule 124 (var_cte -> CTE_F .)
    LB              reduce using rule 124 (var_cte -> CTE_F .)
    SEMICOL         reduce using rule 124 (var_cte -> CTE_F .)
    RP              reduce using rule 124 (var_cte -> CTE_F .)
    COMMA           reduce using rule 124 (var_cte -> CTE_F .)
    RC              reduce using rule 124 (var_cte -> CTE_F .)


state 202

    (125) var_cte -> CTE_B .

    MUL             reduce using rule 125 (var_cte -> CTE_B .)
    DIV             reduce using rule 125 (var_cte -> CTE_B .)
    PLUS            reduce using rule 125 (var_cte -> CTE_B .)
    MINUS           reduce using rule 125 (var_cte -> CTE_B .)
    GEQ             reduce using rule 125 (var_cte -> CTE_B .)
    LEQ             reduce using rule 125 (var_cte -> CTE_B .)
    GT              reduce using rule 125 (var_cte -> CTE_B .)
    LT              reduce using rule 125 (var_cte -> CTE_B .)
    EQUAL           reduce using rule 125 (var_cte -> CTE_B .)
    NEQ             reduce using rule 125 (var_cte -> CTE_B .)
    AND             reduce using rule 125 (var_cte -> CTE_B .)
    OR              reduce using rule 125 (var_cte -> CTE_B .)
    LB              reduce using rule 125 (var_cte -> CTE_B .)
    SEMICOL         reduce using rule 125 (var_cte -> CTE_B .)
    RP              reduce using rule 125 (var_cte -> CTE_B .)
    COMMA           reduce using rule 125 (var_cte -> CTE_B .)
    RC              reduce using rule 125 (var_cte -> CTE_B .)


state 203

    (83) loop -> WHILE expression block .

    PRINT           reduce using rule 83 (loop -> WHILE expression block .)
    INPUT           reduce using rule 83 (loop -> WHILE expression block .)
    IF              reduce using rule 83 (loop -> WHILE expression block .)
    WHILE           reduce using rule 83 (loop -> WHILE expression block .)
    RETURN          reduce using rule 83 (loop -> WHILE expression block .)
    ID              reduce using rule 83 (loop -> WHILE expression block .)
    RB              reduce using rule 83 (loop -> WHILE expression block .)


state 204

    (75) return -> RETURN expression SEMICOL .

    PRINT           reduce using rule 75 (return -> RETURN expression SEMICOL .)
    INPUT           reduce using rule 75 (return -> RETURN expression SEMICOL .)
    IF              reduce using rule 75 (return -> RETURN expression SEMICOL .)
    WHILE           reduce using rule 75 (return -> RETURN expression SEMICOL .)
    RETURN          reduce using rule 75 (return -> RETURN expression SEMICOL .)
    ID              reduce using rule 75 (return -> RETURN expression SEMICOL .)
    RB              reduce using rule 75 (return -> RETURN expression SEMICOL .)


state 205

    (76) obj -> ID array attribute .

    IS              reduce using rule 76 (obj -> ID array attribute .)
    LP              reduce using rule 76 (obj -> ID array attribute .)
    RP              reduce using rule 76 (obj -> ID array attribute .)
    MUL             reduce using rule 76 (obj -> ID array attribute .)
    DIV             reduce using rule 76 (obj -> ID array attribute .)
    PLUS            reduce using rule 76 (obj -> ID array attribute .)
    MINUS           reduce using rule 76 (obj -> ID array attribute .)
    GEQ             reduce using rule 76 (obj -> ID array attribute .)
    LEQ             reduce using rule 76 (obj -> ID array attribute .)
    GT              reduce using rule 76 (obj -> ID array attribute .)
    LT              reduce using rule 76 (obj -> ID array attribute .)
    EQUAL           reduce using rule 76 (obj -> ID array attribute .)
    NEQ             reduce using rule 76 (obj -> ID array attribute .)
    AND             reduce using rule 76 (obj -> ID array attribute .)
    OR              reduce using rule 76 (obj -> ID array attribute .)
    LB              reduce using rule 76 (obj -> ID array attribute .)
    SEMICOL         reduce using rule 76 (obj -> ID array attribute .)
    COMMA           reduce using rule 76 (obj -> ID array attribute .)
    RC              reduce using rule 76 (obj -> ID array attribute .)


state 206

    (130) attribute -> DOT . ID

    ID              shift and go to state 233


state 207

    (131) attribute -> empty .

    IS              reduce using rule 131 (attribute -> empty .)
    LP              reduce using rule 131 (attribute -> empty .)
    RP              reduce using rule 131 (attribute -> empty .)
    MUL             reduce using rule 131 (attribute -> empty .)
    DIV             reduce using rule 131 (attribute -> empty .)
    PLUS            reduce using rule 131 (attribute -> empty .)
    MINUS           reduce using rule 131 (attribute -> empty .)
    GEQ             reduce using rule 131 (attribute -> empty .)
    LEQ             reduce using rule 131 (attribute -> empty .)
    GT              reduce using rule 131 (attribute -> empty .)
    LT              reduce using rule 131 (attribute -> empty .)
    EQUAL           reduce using rule 131 (attribute -> empty .)
    NEQ             reduce using rule 131 (attribute -> empty .)
    AND             reduce using rule 131 (attribute -> empty .)
    OR              reduce using rule 131 (attribute -> empty .)
    LB              reduce using rule 131 (attribute -> empty .)
    SEMICOL         reduce using rule 131 (attribute -> empty .)
    COMMA           reduce using rule 131 (attribute -> empty .)
    RC              reduce using rule 131 (attribute -> empty .)


state 208

    (126) array -> LC expression . RC array_a

    RC              shift and go to state 234


state 209

    (15) typeM -> LC CTE_I RC LC CTE_I RC . atomic type1
    (22) atomic -> . INT atomic_type
    (23) atomic -> . FLOAT atomic_type
    (24) atomic -> . BOOL atomic_type

    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    BOOL            shift and go to state 38

    atomic                         shift and go to state 235

state 210

    (46) block -> LB block_a . RB

    RB              shift and go to state 236


state 211

    (78) print -> PRINT LP print_a RP . SEMICOL

    SEMICOL         shift and go to state 237


state 212

    (82) input -> INPUT LP obj RP . SEMICOL

    SEMICOL         shift and go to state 238


state 213

    (77) assignment -> obj IS expression SEMICOL .

    PRINT           reduce using rule 77 (assignment -> obj IS expression SEMICOL .)
    INPUT           reduce using rule 77 (assignment -> obj IS expression SEMICOL .)
    IF              reduce using rule 77 (assignment -> obj IS expression SEMICOL .)
    WHILE           reduce using rule 77 (assignment -> obj IS expression SEMICOL .)
    RETURN          reduce using rule 77 (assignment -> obj IS expression SEMICOL .)
    ID              reduce using rule 77 (assignment -> obj IS expression SEMICOL .)
    RB              reduce using rule 77 (assignment -> obj IS expression SEMICOL .)


state 214

    (132) call_func -> LP call_params RP .

    SEMICOL         reduce using rule 132 (call_func -> LP call_params RP .)
    MUL             reduce using rule 132 (call_func -> LP call_params RP .)
    DIV             reduce using rule 132 (call_func -> LP call_params RP .)
    PLUS            reduce using rule 132 (call_func -> LP call_params RP .)
    MINUS           reduce using rule 132 (call_func -> LP call_params RP .)
    GEQ             reduce using rule 132 (call_func -> LP call_params RP .)
    LEQ             reduce using rule 132 (call_func -> LP call_params RP .)
    GT              reduce using rule 132 (call_func -> LP call_params RP .)
    LT              reduce using rule 132 (call_func -> LP call_params RP .)
    EQUAL           reduce using rule 132 (call_func -> LP call_params RP .)
    NEQ             reduce using rule 132 (call_func -> LP call_params RP .)
    AND             reduce using rule 132 (call_func -> LP call_params RP .)
    OR              reduce using rule 132 (call_func -> LP call_params RP .)
    LB              reduce using rule 132 (call_func -> LP call_params RP .)
    RP              reduce using rule 132 (call_func -> LP call_params RP .)
    COMMA           reduce using rule 132 (call_func -> LP call_params RP .)
    RC              reduce using rule 132 (call_func -> LP call_params RP .)


state 215

    (85) call_params -> expression call_params_a .

    RP              reduce using rule 85 (call_params -> expression call_params_a .)


state 216

    (87) call_params_a -> COMMA . expression call_params_a
    (96) expression -> . comparison expression_a
    (100) comparison -> . exp comparison_a
    (109) exp -> . term exp_a
    (113) term -> . factor term_a
    (117) factor -> . LP expression RP
    (118) factor -> . factor_a var_cte
    (119) factor_a -> . MINUS
    (120) factor_a -> . NOT
    (121) factor_a -> . empty
    (135) empty -> .

    LP              shift and go to state 148
    MINUS           shift and go to state 150
    NOT             shift and go to state 151
    CTE_I           reduce using rule 135 (empty -> .)
    CTE_F           reduce using rule 135 (empty -> .)
    CTE_B           reduce using rule 135 (empty -> .)
    ID              reduce using rule 135 (empty -> .)

    expression                     shift and go to state 239
    comparison                     shift and go to state 144
    exp                            shift and go to state 145
    term                           shift and go to state 146
    factor                         shift and go to state 147
    factor_a                       shift and go to state 149
    empty                          shift and go to state 152

state 217

    (88) call_params_a -> empty .

    RP              reduce using rule 88 (call_params_a -> empty .)


state 218

    (89) condition -> IF expression block condition_a . condition_b
    (92) condition_b -> . else
    (93) condition_b -> . empty
    (95) else -> . ELSE block
    (135) empty -> .

    ELSE            shift and go to state 243
    PRINT           reduce using rule 135 (empty -> .)
    INPUT           reduce using rule 135 (empty -> .)
    IF              reduce using rule 135 (empty -> .)
    WHILE           reduce using rule 135 (empty -> .)
    RETURN          reduce using rule 135 (empty -> .)
    ID              reduce using rule 135 (empty -> .)
    RB              reduce using rule 135 (empty -> .)

    condition_b                    shift and go to state 240
    else                           shift and go to state 241
    empty                          shift and go to state 242

state 219

    (90) condition_a -> elseif . condition_a
    (90) condition_a -> . elseif condition_a
    (91) condition_a -> . empty
    (94) elseif -> . ELSEIF expression block
    (135) empty -> .

    ELSEIF          shift and go to state 221
    ELSE            reduce using rule 135 (empty -> .)
    PRINT           reduce using rule 135 (empty -> .)
    INPUT           reduce using rule 135 (empty -> .)
    IF              reduce using rule 135 (empty -> .)
    WHILE           reduce using rule 135 (empty -> .)
    RETURN          reduce using rule 135 (empty -> .)
    ID              reduce using rule 135 (empty -> .)
    RB              reduce using rule 135 (empty -> .)

    elseif                         shift and go to state 219
    condition_a                    shift and go to state 244
    empty                          shift and go to state 220

state 220

    (91) condition_a -> empty .

    ELSE            reduce using rule 91 (condition_a -> empty .)
    PRINT           reduce using rule 91 (condition_a -> empty .)
    INPUT           reduce using rule 91 (condition_a -> empty .)
    IF              reduce using rule 91 (condition_a -> empty .)
    WHILE           reduce using rule 91 (condition_a -> empty .)
    RETURN          reduce using rule 91 (condition_a -> empty .)
    ID              reduce using rule 91 (condition_a -> empty .)
    RB              reduce using rule 91 (condition_a -> empty .)


state 221

    (94) elseif -> ELSEIF . expression block
    (96) expression -> . comparison expression_a
    (100) comparison -> . exp comparison_a
    (109) exp -> . term exp_a
    (113) term -> . factor term_a
    (117) factor -> . LP expression RP
    (118) factor -> . factor_a var_cte
    (119) factor_a -> . MINUS
    (120) factor_a -> . NOT
    (121) factor_a -> . empty
    (135) empty -> .

    LP              shift and go to state 148
    MINUS           shift and go to state 150
    NOT             shift and go to state 151
    CTE_I           reduce using rule 135 (empty -> .)
    CTE_F           reduce using rule 135 (empty -> .)
    CTE_B           reduce using rule 135 (empty -> .)
    ID              reduce using rule 135 (empty -> .)

    expression                     shift and go to state 245
    comparison                     shift and go to state 144
    exp                            shift and go to state 145
    term                           shift and go to state 146
    factor                         shift and go to state 147
    factor_a                       shift and go to state 149
    empty                          shift and go to state 152

state 222

    (97) expression_a -> AND comparison . expression_a
    (97) expression_a -> . AND comparison expression_a
    (98) expression_a -> . OR comparison
    (99) expression_a -> . empty
    (135) empty -> .

    AND             shift and go to state 177
    OR              shift and go to state 178
    LB              reduce using rule 135 (empty -> .)
    SEMICOL         reduce using rule 135 (empty -> .)
    RP              reduce using rule 135 (empty -> .)
    COMMA           reduce using rule 135 (empty -> .)
    RC              reduce using rule 135 (empty -> .)

    expression_a                   shift and go to state 246
    empty                          shift and go to state 179

state 223

    (98) expression_a -> OR comparison .

    LB              reduce using rule 98 (expression_a -> OR comparison .)
    SEMICOL         reduce using rule 98 (expression_a -> OR comparison .)
    RP              reduce using rule 98 (expression_a -> OR comparison .)
    COMMA           reduce using rule 98 (expression_a -> OR comparison .)
    RC              reduce using rule 98 (expression_a -> OR comparison .)


state 224

    (101) comparison_a -> comparison_b exp . comparison_a
    (101) comparison_a -> . comparison_b exp comparison_a
    (102) comparison_a -> . empty
    (103) comparison_b -> . GEQ
    (104) comparison_b -> . LEQ
    (105) comparison_b -> . GT
    (106) comparison_b -> . LT
    (107) comparison_b -> . EQUAL
    (108) comparison_b -> . NEQ
    (135) empty -> .

    GEQ             shift and go to state 183
    LEQ             shift and go to state 184
    GT              shift and go to state 185
    LT              shift and go to state 186
    EQUAL           shift and go to state 187
    NEQ             shift and go to state 188
    AND             reduce using rule 135 (empty -> .)
    OR              reduce using rule 135 (empty -> .)
    LB              reduce using rule 135 (empty -> .)
    SEMICOL         reduce using rule 135 (empty -> .)
    RP              reduce using rule 135 (empty -> .)
    COMMA           reduce using rule 135 (empty -> .)
    RC              reduce using rule 135 (empty -> .)

    comparison_b                   shift and go to state 181
    comparison_a                   shift and go to state 247
    empty                          shift and go to state 182

state 225

    (110) exp_a -> PLUS term . exp_a
    (110) exp_a -> . PLUS term exp_a
    (111) exp_a -> . MINUS term exp_a
    (112) exp_a -> . empty
    (135) empty -> .

    PLUS            shift and go to state 190
    MINUS           shift and go to state 191
    GEQ             reduce using rule 135 (empty -> .)
    LEQ             reduce using rule 135 (empty -> .)
    GT              reduce using rule 135 (empty -> .)
    LT              reduce using rule 135 (empty -> .)
    EQUAL           reduce using rule 135 (empty -> .)
    NEQ             reduce using rule 135 (empty -> .)
    AND             reduce using rule 135 (empty -> .)
    OR              reduce using rule 135 (empty -> .)
    LB              reduce using rule 135 (empty -> .)
    SEMICOL         reduce using rule 135 (empty -> .)
    RP              reduce using rule 135 (empty -> .)
    COMMA           reduce using rule 135 (empty -> .)
    RC              reduce using rule 135 (empty -> .)

    exp_a                          shift and go to state 248
    empty                          shift and go to state 192

state 226

    (111) exp_a -> MINUS term . exp_a
    (110) exp_a -> . PLUS term exp_a
    (111) exp_a -> . MINUS term exp_a
    (112) exp_a -> . empty
    (135) empty -> .

    PLUS            shift and go to state 190
    MINUS           shift and go to state 191
    GEQ             reduce using rule 135 (empty -> .)
    LEQ             reduce using rule 135 (empty -> .)
    GT              reduce using rule 135 (empty -> .)
    LT              reduce using rule 135 (empty -> .)
    EQUAL           reduce using rule 135 (empty -> .)
    NEQ             reduce using rule 135 (empty -> .)
    AND             reduce using rule 135 (empty -> .)
    OR              reduce using rule 135 (empty -> .)
    LB              reduce using rule 135 (empty -> .)
    SEMICOL         reduce using rule 135 (empty -> .)
    RP              reduce using rule 135 (empty -> .)
    COMMA           reduce using rule 135 (empty -> .)
    RC              reduce using rule 135 (empty -> .)

    exp_a                          shift and go to state 249
    empty                          shift and go to state 192

state 227

    (114) term_a -> MUL factor . term_a
    (114) term_a -> . MUL factor term_a
    (115) term_a -> . DIV factor term_a
    (116) term_a -> . empty
    (135) empty -> .

    MUL             shift and go to state 194
    DIV             shift and go to state 195
    PLUS            reduce using rule 135 (empty -> .)
    MINUS           reduce using rule 135 (empty -> .)
    GEQ             reduce using rule 135 (empty -> .)
    LEQ             reduce using rule 135 (empty -> .)
    GT              reduce using rule 135 (empty -> .)
    LT              reduce using rule 135 (empty -> .)
    EQUAL           reduce using rule 135 (empty -> .)
    NEQ             reduce using rule 135 (empty -> .)
    AND             reduce using rule 135 (empty -> .)
    OR              reduce using rule 135 (empty -> .)
    LB              reduce using rule 135 (empty -> .)
    SEMICOL         reduce using rule 135 (empty -> .)
    RP              reduce using rule 135 (empty -> .)
    COMMA           reduce using rule 135 (empty -> .)
    RC              reduce using rule 135 (empty -> .)

    term_a                         shift and go to state 250
    empty                          shift and go to state 196

state 228

    (115) term_a -> DIV factor . term_a
    (114) term_a -> . MUL factor term_a
    (115) term_a -> . DIV factor term_a
    (116) term_a -> . empty
    (135) empty -> .

    MUL             shift and go to state 194
    DIV             shift and go to state 195
    PLUS            reduce using rule 135 (empty -> .)
    MINUS           reduce using rule 135 (empty -> .)
    GEQ             reduce using rule 135 (empty -> .)
    LEQ             reduce using rule 135 (empty -> .)
    GT              reduce using rule 135 (empty -> .)
    LT              reduce using rule 135 (empty -> .)
    EQUAL           reduce using rule 135 (empty -> .)
    NEQ             reduce using rule 135 (empty -> .)
    AND             reduce using rule 135 (empty -> .)
    OR              reduce using rule 135 (empty -> .)
    LB              reduce using rule 135 (empty -> .)
    SEMICOL         reduce using rule 135 (empty -> .)
    RP              reduce using rule 135 (empty -> .)
    COMMA           reduce using rule 135 (empty -> .)
    RC              reduce using rule 135 (empty -> .)

    term_a                         shift and go to state 251
    empty                          shift and go to state 196

state 229

    (117) factor -> LP expression RP .

    MUL             reduce using rule 117 (factor -> LP expression RP .)
    DIV             reduce using rule 117 (factor -> LP expression RP .)
    PLUS            reduce using rule 117 (factor -> LP expression RP .)
    MINUS           reduce using rule 117 (factor -> LP expression RP .)
    GEQ             reduce using rule 117 (factor -> LP expression RP .)
    LEQ             reduce using rule 117 (factor -> LP expression RP .)
    GT              reduce using rule 117 (factor -> LP expression RP .)
    LT              reduce using rule 117 (factor -> LP expression RP .)
    EQUAL           reduce using rule 117 (factor -> LP expression RP .)
    NEQ             reduce using rule 117 (factor -> LP expression RP .)
    AND             reduce using rule 117 (factor -> LP expression RP .)
    OR              reduce using rule 117 (factor -> LP expression RP .)
    LB              reduce using rule 117 (factor -> LP expression RP .)
    SEMICOL         reduce using rule 117 (factor -> LP expression RP .)
    RP              reduce using rule 117 (factor -> LP expression RP .)
    COMMA           reduce using rule 117 (factor -> LP expression RP .)
    RC              reduce using rule 117 (factor -> LP expression RP .)


state 230

    (122) var_cte -> obj call_func_optional .

    MUL             reduce using rule 122 (var_cte -> obj call_func_optional .)
    DIV             reduce using rule 122 (var_cte -> obj call_func_optional .)
    PLUS            reduce using rule 122 (var_cte -> obj call_func_optional .)
    MINUS           reduce using rule 122 (var_cte -> obj call_func_optional .)
    GEQ             reduce using rule 122 (var_cte -> obj call_func_optional .)
    LEQ             reduce using rule 122 (var_cte -> obj call_func_optional .)
    GT              reduce using rule 122 (var_cte -> obj call_func_optional .)
    LT              reduce using rule 122 (var_cte -> obj call_func_optional .)
    EQUAL           reduce using rule 122 (var_cte -> obj call_func_optional .)
    NEQ             reduce using rule 122 (var_cte -> obj call_func_optional .)
    AND             reduce using rule 122 (var_cte -> obj call_func_optional .)
    OR              reduce using rule 122 (var_cte -> obj call_func_optional .)
    LB              reduce using rule 122 (var_cte -> obj call_func_optional .)
    SEMICOL         reduce using rule 122 (var_cte -> obj call_func_optional .)
    RP              reduce using rule 122 (var_cte -> obj call_func_optional .)
    COMMA           reduce using rule 122 (var_cte -> obj call_func_optional .)
    RC              reduce using rule 122 (var_cte -> obj call_func_optional .)


state 231

    (133) call_func_optional -> call_func .

    MUL             reduce using rule 133 (call_func_optional -> call_func .)
    DIV             reduce using rule 133 (call_func_optional -> call_func .)
    PLUS            reduce using rule 133 (call_func_optional -> call_func .)
    MINUS           reduce using rule 133 (call_func_optional -> call_func .)
    GEQ             reduce using rule 133 (call_func_optional -> call_func .)
    LEQ             reduce using rule 133 (call_func_optional -> call_func .)
    GT              reduce using rule 133 (call_func_optional -> call_func .)
    LT              reduce using rule 133 (call_func_optional -> call_func .)
    EQUAL           reduce using rule 133 (call_func_optional -> call_func .)
    NEQ             reduce using rule 133 (call_func_optional -> call_func .)
    AND             reduce using rule 133 (call_func_optional -> call_func .)
    OR              reduce using rule 133 (call_func_optional -> call_func .)
    LB              reduce using rule 133 (call_func_optional -> call_func .)
    SEMICOL         reduce using rule 133 (call_func_optional -> call_func .)
    RP              reduce using rule 133 (call_func_optional -> call_func .)
    COMMA           reduce using rule 133 (call_func_optional -> call_func .)
    RC              reduce using rule 133 (call_func_optional -> call_func .)


state 232

    (134) call_func_optional -> empty .

    MUL             reduce using rule 134 (call_func_optional -> empty .)
    DIV             reduce using rule 134 (call_func_optional -> empty .)
    PLUS            reduce using rule 134 (call_func_optional -> empty .)
    MINUS           reduce using rule 134 (call_func_optional -> empty .)
    GEQ             reduce using rule 134 (call_func_optional -> empty .)
    LEQ             reduce using rule 134 (call_func_optional -> empty .)
    GT              reduce using rule 134 (call_func_optional -> empty .)
    LT              reduce using rule 134 (call_func_optional -> empty .)
    EQUAL           reduce using rule 134 (call_func_optional -> empty .)
    NEQ             reduce using rule 134 (call_func_optional -> empty .)
    AND             reduce using rule 134 (call_func_optional -> empty .)
    OR              reduce using rule 134 (call_func_optional -> empty .)
    LB              reduce using rule 134 (call_func_optional -> empty .)
    SEMICOL         reduce using rule 134 (call_func_optional -> empty .)
    RP              reduce using rule 134 (call_func_optional -> empty .)
    COMMA           reduce using rule 134 (call_func_optional -> empty .)
    RC              reduce using rule 134 (call_func_optional -> empty .)


state 233

    (130) attribute -> DOT ID .

    IS              reduce using rule 130 (attribute -> DOT ID .)
    LP              reduce using rule 130 (attribute -> DOT ID .)
    RP              reduce using rule 130 (attribute -> DOT ID .)
    MUL             reduce using rule 130 (attribute -> DOT ID .)
    DIV             reduce using rule 130 (attribute -> DOT ID .)
    PLUS            reduce using rule 130 (attribute -> DOT ID .)
    MINUS           reduce using rule 130 (attribute -> DOT ID .)
    GEQ             reduce using rule 130 (attribute -> DOT ID .)
    LEQ             reduce using rule 130 (attribute -> DOT ID .)
    GT              reduce using rule 130 (attribute -> DOT ID .)
    LT              reduce using rule 130 (attribute -> DOT ID .)
    EQUAL           reduce using rule 130 (attribute -> DOT ID .)
    NEQ             reduce using rule 130 (attribute -> DOT ID .)
    AND             reduce using rule 130 (attribute -> DOT ID .)
    OR              reduce using rule 130 (attribute -> DOT ID .)
    LB              reduce using rule 130 (attribute -> DOT ID .)
    SEMICOL         reduce using rule 130 (attribute -> DOT ID .)
    COMMA           reduce using rule 130 (attribute -> DOT ID .)
    RC              reduce using rule 130 (attribute -> DOT ID .)


state 234

    (126) array -> LC expression RC . array_a
    (128) array_a -> . LC expression RC
    (129) array_a -> . empty
    (135) empty -> .

    LC              shift and go to state 252
    DOT             reduce using rule 135 (empty -> .)
    IS              reduce using rule 135 (empty -> .)
    LP              reduce using rule 135 (empty -> .)
    RP              reduce using rule 135 (empty -> .)
    MUL             reduce using rule 135 (empty -> .)
    DIV             reduce using rule 135 (empty -> .)
    PLUS            reduce using rule 135 (empty -> .)
    MINUS           reduce using rule 135 (empty -> .)
    GEQ             reduce using rule 135 (empty -> .)
    LEQ             reduce using rule 135 (empty -> .)
    GT              reduce using rule 135 (empty -> .)
    LT              reduce using rule 135 (empty -> .)
    EQUAL           reduce using rule 135 (empty -> .)
    NEQ             reduce using rule 135 (empty -> .)
    AND             reduce using rule 135 (empty -> .)
    OR              reduce using rule 135 (empty -> .)
    LB              reduce using rule 135 (empty -> .)
    SEMICOL         reduce using rule 135 (empty -> .)
    COMMA           reduce using rule 135 (empty -> .)
    RC              reduce using rule 135 (empty -> .)

    array_a                        shift and go to state 253
    empty                          shift and go to state 254

state 235

    (15) typeM -> LC CTE_I RC LC CTE_I RC atomic . type1
    (18) type1 -> .

    SEMICOL         reduce using rule 18 (type1 -> .)

    type1                          shift and go to state 255

state 236

    (46) block -> LB block_a RB .

    INIT            reduce using rule 46 (block -> LB block_a RB .)
    PRIVATE         reduce using rule 46 (block -> LB block_a RB .)
    RB              reduce using rule 46 (block -> LB block_a RB .)
    FUNCTION        reduce using rule 46 (block -> LB block_a RB .)
    ELSEIF          reduce using rule 46 (block -> LB block_a RB .)
    ELSE            reduce using rule 46 (block -> LB block_a RB .)
    PRINT           reduce using rule 46 (block -> LB block_a RB .)
    INPUT           reduce using rule 46 (block -> LB block_a RB .)
    IF              reduce using rule 46 (block -> LB block_a RB .)
    WHILE           reduce using rule 46 (block -> LB block_a RB .)
    RETURN          reduce using rule 46 (block -> LB block_a RB .)
    ID              reduce using rule 46 (block -> LB block_a RB .)


state 237

    (78) print -> PRINT LP print_a RP SEMICOL .

    PRINT           reduce using rule 78 (print -> PRINT LP print_a RP SEMICOL .)
    INPUT           reduce using rule 78 (print -> PRINT LP print_a RP SEMICOL .)
    IF              reduce using rule 78 (print -> PRINT LP print_a RP SEMICOL .)
    WHILE           reduce using rule 78 (print -> PRINT LP print_a RP SEMICOL .)
    RETURN          reduce using rule 78 (print -> PRINT LP print_a RP SEMICOL .)
    ID              reduce using rule 78 (print -> PRINT LP print_a RP SEMICOL .)
    RB              reduce using rule 78 (print -> PRINT LP print_a RP SEMICOL .)


state 238

    (82) input -> INPUT LP obj RP SEMICOL .

    PRINT           reduce using rule 82 (input -> INPUT LP obj RP SEMICOL .)
    INPUT           reduce using rule 82 (input -> INPUT LP obj RP SEMICOL .)
    IF              reduce using rule 82 (input -> INPUT LP obj RP SEMICOL .)
    WHILE           reduce using rule 82 (input -> INPUT LP obj RP SEMICOL .)
    RETURN          reduce using rule 82 (input -> INPUT LP obj RP SEMICOL .)
    ID              reduce using rule 82 (input -> INPUT LP obj RP SEMICOL .)
    RB              reduce using rule 82 (input -> INPUT LP obj RP SEMICOL .)


state 239

    (87) call_params_a -> COMMA expression . call_params_a
    (87) call_params_a -> . COMMA expression call_params_a
    (88) call_params_a -> . empty
    (135) empty -> .

    COMMA           shift and go to state 216
    RP              reduce using rule 135 (empty -> .)

    call_params_a                  shift and go to state 256
    empty                          shift and go to state 217

state 240

    (89) condition -> IF expression block condition_a condition_b .

    PRINT           reduce using rule 89 (condition -> IF expression block condition_a condition_b .)
    INPUT           reduce using rule 89 (condition -> IF expression block condition_a condition_b .)
    IF              reduce using rule 89 (condition -> IF expression block condition_a condition_b .)
    WHILE           reduce using rule 89 (condition -> IF expression block condition_a condition_b .)
    RETURN          reduce using rule 89 (condition -> IF expression block condition_a condition_b .)
    ID              reduce using rule 89 (condition -> IF expression block condition_a condition_b .)
    RB              reduce using rule 89 (condition -> IF expression block condition_a condition_b .)


state 241

    (92) condition_b -> else .

    PRINT           reduce using rule 92 (condition_b -> else .)
    INPUT           reduce using rule 92 (condition_b -> else .)
    IF              reduce using rule 92 (condition_b -> else .)
    WHILE           reduce using rule 92 (condition_b -> else .)
    RETURN          reduce using rule 92 (condition_b -> else .)
    ID              reduce using rule 92 (condition_b -> else .)
    RB              reduce using rule 92 (condition_b -> else .)


state 242

    (93) condition_b -> empty .

    PRINT           reduce using rule 93 (condition_b -> empty .)
    INPUT           reduce using rule 93 (condition_b -> empty .)
    IF              reduce using rule 93 (condition_b -> empty .)
    WHILE           reduce using rule 93 (condition_b -> empty .)
    RETURN          reduce using rule 93 (condition_b -> empty .)
    ID              reduce using rule 93 (condition_b -> empty .)
    RB              reduce using rule 93 (condition_b -> empty .)


state 243

    (95) else -> ELSE . block
    (46) block -> . LB block_a RB

    LB              shift and go to state 164

    block                          shift and go to state 257

state 244

    (90) condition_a -> elseif condition_a .

    ELSE            reduce using rule 90 (condition_a -> elseif condition_a .)
    PRINT           reduce using rule 90 (condition_a -> elseif condition_a .)
    INPUT           reduce using rule 90 (condition_a -> elseif condition_a .)
    IF              reduce using rule 90 (condition_a -> elseif condition_a .)
    WHILE           reduce using rule 90 (condition_a -> elseif condition_a .)
    RETURN          reduce using rule 90 (condition_a -> elseif condition_a .)
    ID              reduce using rule 90 (condition_a -> elseif condition_a .)
    RB              reduce using rule 90 (condition_a -> elseif condition_a .)


state 245

    (94) elseif -> ELSEIF expression . block
    (46) block -> . LB block_a RB

    LB              shift and go to state 164

    block                          shift and go to state 258

state 246

    (97) expression_a -> AND comparison expression_a .

    LB              reduce using rule 97 (expression_a -> AND comparison expression_a .)
    SEMICOL         reduce using rule 97 (expression_a -> AND comparison expression_a .)
    RP              reduce using rule 97 (expression_a -> AND comparison expression_a .)
    COMMA           reduce using rule 97 (expression_a -> AND comparison expression_a .)
    RC              reduce using rule 97 (expression_a -> AND comparison expression_a .)


state 247

    (101) comparison_a -> comparison_b exp comparison_a .

    AND             reduce using rule 101 (comparison_a -> comparison_b exp comparison_a .)
    OR              reduce using rule 101 (comparison_a -> comparison_b exp comparison_a .)
    LB              reduce using rule 101 (comparison_a -> comparison_b exp comparison_a .)
    SEMICOL         reduce using rule 101 (comparison_a -> comparison_b exp comparison_a .)
    RP              reduce using rule 101 (comparison_a -> comparison_b exp comparison_a .)
    COMMA           reduce using rule 101 (comparison_a -> comparison_b exp comparison_a .)
    RC              reduce using rule 101 (comparison_a -> comparison_b exp comparison_a .)


state 248

    (110) exp_a -> PLUS term exp_a .

    GEQ             reduce using rule 110 (exp_a -> PLUS term exp_a .)
    LEQ             reduce using rule 110 (exp_a -> PLUS term exp_a .)
    GT              reduce using rule 110 (exp_a -> PLUS term exp_a .)
    LT              reduce using rule 110 (exp_a -> PLUS term exp_a .)
    EQUAL           reduce using rule 110 (exp_a -> PLUS term exp_a .)
    NEQ             reduce using rule 110 (exp_a -> PLUS term exp_a .)
    AND             reduce using rule 110 (exp_a -> PLUS term exp_a .)
    OR              reduce using rule 110 (exp_a -> PLUS term exp_a .)
    LB              reduce using rule 110 (exp_a -> PLUS term exp_a .)
    SEMICOL         reduce using rule 110 (exp_a -> PLUS term exp_a .)
    RP              reduce using rule 110 (exp_a -> PLUS term exp_a .)
    COMMA           reduce using rule 110 (exp_a -> PLUS term exp_a .)
    RC              reduce using rule 110 (exp_a -> PLUS term exp_a .)


state 249

    (111) exp_a -> MINUS term exp_a .

    GEQ             reduce using rule 111 (exp_a -> MINUS term exp_a .)
    LEQ             reduce using rule 111 (exp_a -> MINUS term exp_a .)
    GT              reduce using rule 111 (exp_a -> MINUS term exp_a .)
    LT              reduce using rule 111 (exp_a -> MINUS term exp_a .)
    EQUAL           reduce using rule 111 (exp_a -> MINUS term exp_a .)
    NEQ             reduce using rule 111 (exp_a -> MINUS term exp_a .)
    AND             reduce using rule 111 (exp_a -> MINUS term exp_a .)
    OR              reduce using rule 111 (exp_a -> MINUS term exp_a .)
    LB              reduce using rule 111 (exp_a -> MINUS term exp_a .)
    SEMICOL         reduce using rule 111 (exp_a -> MINUS term exp_a .)
    RP              reduce using rule 111 (exp_a -> MINUS term exp_a .)
    COMMA           reduce using rule 111 (exp_a -> MINUS term exp_a .)
    RC              reduce using rule 111 (exp_a -> MINUS term exp_a .)


state 250

    (114) term_a -> MUL factor term_a .

    PLUS            reduce using rule 114 (term_a -> MUL factor term_a .)
    MINUS           reduce using rule 114 (term_a -> MUL factor term_a .)
    GEQ             reduce using rule 114 (term_a -> MUL factor term_a .)
    LEQ             reduce using rule 114 (term_a -> MUL factor term_a .)
    GT              reduce using rule 114 (term_a -> MUL factor term_a .)
    LT              reduce using rule 114 (term_a -> MUL factor term_a .)
    EQUAL           reduce using rule 114 (term_a -> MUL factor term_a .)
    NEQ             reduce using rule 114 (term_a -> MUL factor term_a .)
    AND             reduce using rule 114 (term_a -> MUL factor term_a .)
    OR              reduce using rule 114 (term_a -> MUL factor term_a .)
    LB              reduce using rule 114 (term_a -> MUL factor term_a .)
    SEMICOL         reduce using rule 114 (term_a -> MUL factor term_a .)
    RP              reduce using rule 114 (term_a -> MUL factor term_a .)
    COMMA           reduce using rule 114 (term_a -> MUL factor term_a .)
    RC              reduce using rule 114 (term_a -> MUL factor term_a .)


state 251

    (115) term_a -> DIV factor term_a .

    PLUS            reduce using rule 115 (term_a -> DIV factor term_a .)
    MINUS           reduce using rule 115 (term_a -> DIV factor term_a .)
    GEQ             reduce using rule 115 (term_a -> DIV factor term_a .)
    LEQ             reduce using rule 115 (term_a -> DIV factor term_a .)
    GT              reduce using rule 115 (term_a -> DIV factor term_a .)
    LT              reduce using rule 115 (term_a -> DIV factor term_a .)
    EQUAL           reduce using rule 115 (term_a -> DIV factor term_a .)
    NEQ             reduce using rule 115 (term_a -> DIV factor term_a .)
    AND             reduce using rule 115 (term_a -> DIV factor term_a .)
    OR              reduce using rule 115 (term_a -> DIV factor term_a .)
    LB              reduce using rule 115 (term_a -> DIV factor term_a .)
    SEMICOL         reduce using rule 115 (term_a -> DIV factor term_a .)
    RP              reduce using rule 115 (term_a -> DIV factor term_a .)
    COMMA           reduce using rule 115 (term_a -> DIV factor term_a .)
    RC              reduce using rule 115 (term_a -> DIV factor term_a .)


state 252

    (128) array_a -> LC . expression RC
    (96) expression -> . comparison expression_a
    (100) comparison -> . exp comparison_a
    (109) exp -> . term exp_a
    (113) term -> . factor term_a
    (117) factor -> . LP expression RP
    (118) factor -> . factor_a var_cte
    (119) factor_a -> . MINUS
    (120) factor_a -> . NOT
    (121) factor_a -> . empty
    (135) empty -> .

    LP              shift and go to state 148
    MINUS           shift and go to state 150
    NOT             shift and go to state 151
    CTE_I           reduce using rule 135 (empty -> .)
    CTE_F           reduce using rule 135 (empty -> .)
    CTE_B           reduce using rule 135 (empty -> .)
    ID              reduce using rule 135 (empty -> .)

    expression                     shift and go to state 259
    comparison                     shift and go to state 144
    exp                            shift and go to state 145
    term                           shift and go to state 146
    factor                         shift and go to state 147
    factor_a                       shift and go to state 149
    empty                          shift and go to state 152

state 253

    (126) array -> LC expression RC array_a .

    DOT             reduce using rule 126 (array -> LC expression RC array_a .)
    IS              reduce using rule 126 (array -> LC expression RC array_a .)
    LP              reduce using rule 126 (array -> LC expression RC array_a .)
    RP              reduce using rule 126 (array -> LC expression RC array_a .)
    MUL             reduce using rule 126 (array -> LC expression RC array_a .)
    DIV             reduce using rule 126 (array -> LC expression RC array_a .)
    PLUS            reduce using rule 126 (array -> LC expression RC array_a .)
    MINUS           reduce using rule 126 (array -> LC expression RC array_a .)
    GEQ             reduce using rule 126 (array -> LC expression RC array_a .)
    LEQ             reduce using rule 126 (array -> LC expression RC array_a .)
    GT              reduce using rule 126 (array -> LC expression RC array_a .)
    LT              reduce using rule 126 (array -> LC expression RC array_a .)
    EQUAL           reduce using rule 126 (array -> LC expression RC array_a .)
    NEQ             reduce using rule 126 (array -> LC expression RC array_a .)
    AND             reduce using rule 126 (array -> LC expression RC array_a .)
    OR              reduce using rule 126 (array -> LC expression RC array_a .)
    LB              reduce using rule 126 (array -> LC expression RC array_a .)
    SEMICOL         reduce using rule 126 (array -> LC expression RC array_a .)
    COMMA           reduce using rule 126 (array -> LC expression RC array_a .)
    RC              reduce using rule 126 (array -> LC expression RC array_a .)


state 254

    (129) array_a -> empty .

    DOT             reduce using rule 129 (array_a -> empty .)
    IS              reduce using rule 129 (array_a -> empty .)
    LP              reduce using rule 129 (array_a -> empty .)
    RP              reduce using rule 129 (array_a -> empty .)
    MUL             reduce using rule 129 (array_a -> empty .)
    DIV             reduce using rule 129 (array_a -> empty .)
    PLUS            reduce using rule 129 (array_a -> empty .)
    MINUS           reduce using rule 129 (array_a -> empty .)
    GEQ             reduce using rule 129 (array_a -> empty .)
    LEQ             reduce using rule 129 (array_a -> empty .)
    GT              reduce using rule 129 (array_a -> empty .)
    LT              reduce using rule 129 (array_a -> empty .)
    EQUAL           reduce using rule 129 (array_a -> empty .)
    NEQ             reduce using rule 129 (array_a -> empty .)
    AND             reduce using rule 129 (array_a -> empty .)
    OR              reduce using rule 129 (array_a -> empty .)
    LB              reduce using rule 129 (array_a -> empty .)
    SEMICOL         reduce using rule 129 (array_a -> empty .)
    COMMA           reduce using rule 129 (array_a -> empty .)
    RC              reduce using rule 129 (array_a -> empty .)


state 255

    (15) typeM -> LC CTE_I RC LC CTE_I RC atomic type1 .

    SEMICOL         reduce using rule 15 (typeM -> LC CTE_I RC LC CTE_I RC atomic type1 .)


state 256

    (87) call_params_a -> COMMA expression call_params_a .

    RP              reduce using rule 87 (call_params_a -> COMMA expression call_params_a .)


state 257

    (95) else -> ELSE block .

    PRINT           reduce using rule 95 (else -> ELSE block .)
    INPUT           reduce using rule 95 (else -> ELSE block .)
    IF              reduce using rule 95 (else -> ELSE block .)
    WHILE           reduce using rule 95 (else -> ELSE block .)
    RETURN          reduce using rule 95 (else -> ELSE block .)
    ID              reduce using rule 95 (else -> ELSE block .)
    RB              reduce using rule 95 (else -> ELSE block .)


state 258

    (94) elseif -> ELSEIF expression block .

    ELSEIF          reduce using rule 94 (elseif -> ELSEIF expression block .)
    ELSE            reduce using rule 94 (elseif -> ELSEIF expression block .)
    PRINT           reduce using rule 94 (elseif -> ELSEIF expression block .)
    INPUT           reduce using rule 94 (elseif -> ELSEIF expression block .)
    IF              reduce using rule 94 (elseif -> ELSEIF expression block .)
    WHILE           reduce using rule 94 (elseif -> ELSEIF expression block .)
    RETURN          reduce using rule 94 (elseif -> ELSEIF expression block .)
    ID              reduce using rule 94 (elseif -> ELSEIF expression block .)
    RB              reduce using rule 94 (elseif -> ELSEIF expression block .)


state 259

    (128) array_a -> LC expression . RC

    RC              shift and go to state 260


state 260

    (128) array_a -> LC expression RC .

    DOT             reduce using rule 128 (array_a -> LC expression RC .)
    IS              reduce using rule 128 (array_a -> LC expression RC .)
    LP              reduce using rule 128 (array_a -> LC expression RC .)
    RP              reduce using rule 128 (array_a -> LC expression RC .)
    MUL             reduce using rule 128 (array_a -> LC expression RC .)
    DIV             reduce using rule 128 (array_a -> LC expression RC .)
    PLUS            reduce using rule 128 (array_a -> LC expression RC .)
    MINUS           reduce using rule 128 (array_a -> LC expression RC .)
    GEQ             reduce using rule 128 (array_a -> LC expression RC .)
    LEQ             reduce using rule 128 (array_a -> LC expression RC .)
    GT              reduce using rule 128 (array_a -> LC expression RC .)
    LT              reduce using rule 128 (array_a -> LC expression RC .)
    EQUAL           reduce using rule 128 (array_a -> LC expression RC .)
    NEQ             reduce using rule 128 (array_a -> LC expression RC .)
    AND             reduce using rule 128 (array_a -> LC expression RC .)
    OR              reduce using rule 128 (array_a -> LC expression RC .)
    LB              reduce using rule 128 (array_a -> LC expression RC .)
    SEMICOL         reduce using rule 128 (array_a -> LC expression RC .)
    COMMA           reduce using rule 128 (array_a -> LC expression RC .)
    RC              reduce using rule 128 (array_a -> LC expression RC .)

